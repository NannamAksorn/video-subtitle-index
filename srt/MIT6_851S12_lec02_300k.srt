1
00:00:00,000 --> 00:00:00,090


2
00:00:00,090 --> 00:00:02,490
The following content is
provided under a Creative

3
00:00:02,490 --> 00:00:04,030
Commons license.

4
00:00:04,030 --> 00:00:06,360
Your support will help
MIT OpenCourseWare

5
00:00:06,360 --> 00:00:10,720
continue to offer high quality
educational resources for free.

6
00:00:10,720 --> 00:00:13,320
To make a donation or
view additional materials

7
00:00:13,320 --> 00:00:17,280
from hundreds of MIT courses,
visit MIT OpenCourseWare

8
00:00:17,280 --> 00:00:18,450
at ocw.mit.edu.

9
00:00:18,450 --> 00:00:22,110


10
00:00:22,110 --> 00:00:25,092
ERIK DEMAINE: All right,
welcome back to 6.851.

11
00:00:25,092 --> 00:00:28,530
We continue our theme
of time travel today.

12
00:00:28,530 --> 00:00:30,776
Before I get started, I
wanted to briefly talk

13
00:00:30,776 --> 00:00:32,150
about the project,
which I forgot

14
00:00:32,150 --> 00:00:33,650
to talk about in lecture one.

15
00:00:33,650 --> 00:00:36,710
Project is sort of the focus of
your evaluation in the class,

16
00:00:36,710 --> 00:00:38,380
other than problems
sets inscribing,

17
00:00:38,380 --> 00:00:40,590
it's supposed to be
the bulk of the work.

18
00:00:40,590 --> 00:00:42,110
Project can be
theoretical, trying

19
00:00:42,110 --> 00:00:43,151
to solve an open problem.

20
00:00:43,151 --> 00:00:44,510
You don't have to succeed.

21
00:00:44,510 --> 00:00:46,968
If you want to do that, you
should come to the open problem

22
00:00:46,968 --> 00:00:47,480
sessions.

23
00:00:47,480 --> 00:00:51,590
Could be a survey of
things, especially not

24
00:00:51,590 --> 00:00:54,500
covered in class, or not
covered in class in much detail.

25
00:00:54,500 --> 00:00:55,790
Look at a few papers.

26
00:00:55,790 --> 00:00:58,490
Could be an implementation of
one of these data structures.

27
00:00:58,490 --> 00:01:00,890
A lot of the data structures
we're talking about here

28
00:01:00,890 --> 00:01:02,056
have never been implemented.

29
00:01:02,056 --> 00:01:04,069
We don't know how well
they perform in practice,

30
00:01:04,069 --> 00:01:05,300
and it'd cool to find out.

31
00:01:05,300 --> 00:01:07,216
Many of them have though,
so you should do one

32
00:01:07,216 --> 00:01:09,980
that hasn't been done already.

33
00:01:09,980 --> 00:01:11,840
Those are the main
project types.

34
00:01:11,840 --> 00:01:14,300
There will in a
month or so, there

35
00:01:14,300 --> 00:01:16,280
will be a project proposal
deadline where you

36
00:01:16,280 --> 00:01:17,750
have to pick what you're doing.

37
00:01:17,750 --> 00:01:21,500
And then the project itself
is due last day of classes.

38
00:01:21,500 --> 00:01:24,200
And in the last
few lectures, there

39
00:01:24,200 --> 00:01:25,457
will be project presentations.

40
00:01:25,457 --> 00:01:27,290
So you'll also have to
give a talk about it.

41
00:01:27,290 --> 00:01:28,550
You can do group projects.

42
00:01:28,550 --> 00:01:31,850
And for more people we
expect more stuff to be done,

43
00:01:31,850 --> 00:01:33,210
that's all.

44
00:01:33,210 --> 00:01:34,880
Otherwise unconstrained.

45
00:01:34,880 --> 00:01:40,340
So in time travel land,
I guess the most sort

46
00:01:40,340 --> 00:01:43,450
of physically
realistic physics land,

47
00:01:43,450 --> 00:01:45,567
if time travel is
branching universes

48
00:01:45,567 --> 00:01:47,150
where if you make a
change in the past

49
00:01:47,150 --> 00:01:48,441
you get a totally new universe.

50
00:01:48,441 --> 00:01:50,370
That's full persistence.

51
00:01:50,370 --> 00:01:51,772
That's last class.

52
00:01:51,772 --> 00:01:54,230
Today we're going to do the
more science fiction-y approach

53
00:01:54,230 --> 00:01:57,769
to time travel, which
is you can-- like in

54
00:01:57,769 --> 00:01:58,560
Back to the Future.

55
00:01:58,560 --> 00:02:00,560
You can go back in
time, make a change,

56
00:02:00,560 --> 00:02:02,690
and then return to the
present and see all the

57
00:02:02,690 --> 00:02:05,750
intervening-- the result of
all the intervening things that

58
00:02:05,750 --> 00:02:08,120
happen meanwhile.

59
00:02:08,120 --> 00:02:10,250
A fun example of this,
if you haven't seen it,

60
00:02:10,250 --> 00:02:12,830
is the movie Time
Cop, where there's

61
00:02:12,830 --> 00:02:14,810
this guy going back
in time, trying

62
00:02:14,810 --> 00:02:17,810
to fight evil time travelers.

63
00:02:17,810 --> 00:02:20,420
And when he returns
to the present,

64
00:02:20,420 --> 00:02:22,820
sometimes, like the
whole time travel

65
00:02:22,820 --> 00:02:24,140
service is starting to fail.

66
00:02:24,140 --> 00:02:25,370
And there's this worry
that he'll never be

67
00:02:25,370 --> 00:02:26,900
able to return to the present.

68
00:02:26,900 --> 00:02:30,240
So anyway, we want to do
that with the data structure.

69
00:02:30,240 --> 00:02:33,440
So this is the idea
of retroactivity.

70
00:02:33,440 --> 00:02:37,190
In general, we think of a data
structure as having a timeline.

71
00:02:37,190 --> 00:02:46,460


72
00:02:46,460 --> 00:02:52,520
We're going to maintain one
linear timeline of updates.

73
00:02:52,520 --> 00:02:54,650
So here's time.

74
00:02:54,650 --> 00:02:57,990


75
00:02:57,990 --> 00:03:05,810
And the idea is, well, maybe at
time 0 you do an insert of 7.

76
00:03:05,810 --> 00:03:11,600
And then at time 1, you
maybe did an insert of 3.

77
00:03:11,600 --> 00:03:14,630
And then at time 2,
you did a delete-min.

78
00:03:14,630 --> 00:03:18,860


79
00:03:18,860 --> 00:03:19,960
OK, what's that spell?

80
00:03:19,960 --> 00:03:21,200
Or, at the end you have--

81
00:03:21,200 --> 00:03:23,810
right now, you'd have
just the element 7.

82
00:03:23,810 --> 00:03:26,900
In general, every data structure
you can think of is this.

83
00:03:26,900 --> 00:03:30,590
Now normally, we're always
appending to the timeline

84
00:03:30,590 --> 00:03:33,200
that's working in the present.

85
00:03:33,200 --> 00:03:35,900
You're doing operations
on the present.

86
00:03:35,900 --> 00:03:38,300
But we'd like to allow--
with retroactive data

87
00:03:38,300 --> 00:03:40,760
structures you can
go back in time, say

88
00:03:40,760 --> 00:03:43,550
right at the beginning of
time, and say actually I

89
00:03:43,550 --> 00:03:48,660
meant to put, at time minus 1, I
meant to do something insert 4.

90
00:03:48,660 --> 00:03:52,050
Or actually, insert 2 would
be a little more interesting.

91
00:03:52,050 --> 00:03:54,140
Insert 2 is interesting,
because that actually

92
00:03:54,140 --> 00:03:56,990
changes what the delete-min
operation would have done.

93
00:03:56,990 --> 00:03:58,460
And so I want to
go back in time,

94
00:03:58,460 --> 00:04:01,040
do this, and then return to
the present, say what's my data

95
00:04:01,040 --> 00:04:02,510
structure look like now.

96
00:04:02,510 --> 00:04:05,990
I want to be able to do
the regular queries I can.

97
00:04:05,990 --> 00:04:09,530
So let's say you can do
queries at the present.

98
00:04:09,530 --> 00:04:11,420
This is now.

99
00:04:11,420 --> 00:04:15,050
And you can do queries here.

100
00:04:15,050 --> 00:04:21,890
And I want to be able to
add and remove operations.

101
00:04:21,890 --> 00:04:27,170


102
00:04:27,170 --> 00:04:30,650
Update operations at any time.

103
00:04:30,650 --> 00:04:35,430


104
00:04:35,430 --> 00:04:38,780
So that's what's called a
partially retroactive data

105
00:04:38,780 --> 00:04:41,920
structure.

106
00:04:41,920 --> 00:04:45,620
So like persistence, we
have partial and full.

107
00:04:45,620 --> 00:04:51,410
So in general, we're going
to have insert at a given

108
00:04:51,410 --> 00:04:53,525
time, a given update.

109
00:04:53,525 --> 00:04:56,810


110
00:04:56,810 --> 00:05:01,970
Delete the operation
at a given time.

111
00:05:01,970 --> 00:05:02,800
And query.

112
00:05:02,800 --> 00:05:10,610


113
00:05:10,610 --> 00:05:15,290
And I'm going to
use capital letters

114
00:05:15,290 --> 00:05:18,110
to denote retroactive operations
and lower case letters

115
00:05:18,110 --> 00:05:19,470
to denote regular operations.

116
00:05:19,470 --> 00:05:20,820
So it's intentional.

117
00:05:20,820 --> 00:05:22,550
This is an uppercase insert.

118
00:05:22,550 --> 00:05:23,850
This is a lowercase insert.

119
00:05:23,850 --> 00:05:29,960
So we're inserting an insert
at time, the time before 0.

120
00:05:29,960 --> 00:05:33,380
What exactly does
time mean here?

121
00:05:33,380 --> 00:05:36,395
We're not going to work with
that too much directly today.

122
00:05:36,395 --> 00:05:38,270
You can think of them
as just being integers.

123
00:05:38,270 --> 00:05:41,360
But it gets awkward if you just
keep inserting new operations

124
00:05:41,360 --> 00:05:42,920
to do in between 1 and 2.

125
00:05:42,920 --> 00:05:45,900
There aren't very many
integers between 1 and 2.

126
00:05:45,900 --> 00:05:48,920
One easy solution to this is
use the order maintenance data

127
00:05:48,920 --> 00:05:51,089
structure that we mentioned
in the last class, where

128
00:05:51,089 --> 00:05:52,880
you basically are
maintaining a linked list

129
00:05:52,880 --> 00:05:56,600
and you're able to insert
new times in between any two

130
00:05:56,600 --> 00:05:57,200
given times.

131
00:05:57,200 --> 00:06:00,240
And you can still do order
queries in constant time.

132
00:06:00,240 --> 00:06:02,229
But I mean, if you
don't mind logs

133
00:06:02,229 --> 00:06:04,520
you could just store the
times in a binary search tree.

134
00:06:04,520 --> 00:06:08,280
That's an easy way to do it.

135
00:06:08,280 --> 00:06:12,410
We're not really going to
worry about that too much here.

136
00:06:12,410 --> 00:06:14,120
What we're interested
here is how do we

137
00:06:14,120 --> 00:06:17,600
maintain the sort
of side effects

138
00:06:17,600 --> 00:06:20,210
of doing this operation
earlier in time,

139
00:06:20,210 --> 00:06:23,540
computing all of this,
or chain reactions that

140
00:06:23,540 --> 00:06:26,900
would have happened meanwhile,
sort of butterfly effect.

141
00:06:26,900 --> 00:06:33,980
All right, I want to define
partial retroactivity

142
00:06:33,980 --> 00:06:43,200
means queries are always
done at the present.

143
00:06:43,200 --> 00:06:46,670
Let's say t equals
infinity or now.

144
00:06:46,670 --> 00:06:48,790
This is what you might
call the Q model,

145
00:06:48,790 --> 00:06:50,300
if you're a Star Trek fan.

146
00:06:50,300 --> 00:06:52,479
You can exist in all time
simultaneously, do updates

147
00:06:52,479 --> 00:06:54,020
whenever you feel
like it, do queries

148
00:06:54,020 --> 00:06:57,140
whenever you feel like it.

149
00:06:57,140 --> 00:06:59,780
All right model clear.

150
00:06:59,780 --> 00:07:02,040
Now as you might
expect, this is hard.

151
00:07:02,040 --> 00:07:05,580
You can't always do
retroactivity super well.

152
00:07:05,580 --> 00:07:08,900
But we'll talk about our
situations you can do well

153
00:07:08,900 --> 00:07:10,940
and what you can do in general.

154
00:07:10,940 --> 00:07:15,315


155
00:07:15,315 --> 00:07:20,833
Go to an easy case, which
is still fairly interesting.

156
00:07:20,833 --> 00:07:24,620


157
00:07:24,620 --> 00:07:29,720
Suppose you have
commutative updates,

158
00:07:29,720 --> 00:07:36,672
meaning x followed by y is the
same thing as y followed by x.

159
00:07:36,672 --> 00:07:38,630
This would be great if
I could reorder updates,

160
00:07:38,630 --> 00:07:41,600
because then I don't really care
about the sequence of updates,

161
00:07:41,600 --> 00:07:45,470
as long as I'm only
querying the final results.

162
00:07:45,470 --> 00:07:47,337
If I want to do an
update in the past--

163
00:07:47,337 --> 00:07:49,670
this would not be an example
of commutative-- delete-min

164
00:07:49,670 --> 00:07:51,255
and insert are not commutative.

165
00:07:51,255 --> 00:07:54,770
But if I was just doing
insert and delete for example,

166
00:07:54,770 --> 00:07:58,787
delete 7, whatever,
then inserting 2 here

167
00:07:58,787 --> 00:08:00,620
is the same thing as
inserting 2 at the end,

168
00:08:00,620 --> 00:08:03,230
as long as I'm only
querying the end.

169
00:08:03,230 --> 00:08:06,640
So this would be an easy case
for partial retroactivity.

170
00:08:06,640 --> 00:08:11,660


171
00:08:11,660 --> 00:08:17,450
If my updates are commutative,
then inserting an operation

172
00:08:17,450 --> 00:08:25,670
at time t is the same thing as
inserting that operation now,

173
00:08:25,670 --> 00:08:26,480
at the end of time.

174
00:08:26,480 --> 00:08:29,590


175
00:08:29,590 --> 00:08:30,830
That's for inserts.

176
00:08:30,830 --> 00:08:33,260
But if I want to
also be able to--

177
00:08:33,260 --> 00:08:36,110
for retroactive inserts,
I should say, capital I.

178
00:08:36,110 --> 00:08:39,230
If I want to be able to
do retroactive deletes,

179
00:08:39,230 --> 00:08:40,909
I need something else.

180
00:08:40,909 --> 00:08:41,900
I need some way--

181
00:08:41,900 --> 00:08:45,950
I still want to only work
in the present, if I can.

182
00:08:45,950 --> 00:08:48,680
And for that I need inversion.

183
00:08:48,680 --> 00:08:49,820
I have invertible updates.

184
00:08:49,820 --> 00:08:55,480


185
00:08:55,480 --> 00:08:58,760
If there is some way to,
given an operation x,

186
00:08:58,760 --> 00:09:02,190
compute a new operation x
inverse, that does the reverse,

187
00:09:02,190 --> 00:09:04,610
and that's equivalent
to nothing,

188
00:09:04,610 --> 00:09:08,450
then deleting an operation
is the same thing as doing

189
00:09:08,450 --> 00:09:09,560
the inverse.

190
00:09:09,560 --> 00:09:11,840
And if you have
also commutativity--

191
00:09:11,840 --> 00:09:17,840
so I'm adding these two
constraints-- then delete t

192
00:09:17,840 --> 00:09:27,091
some operation is the same thing
as inserting now that operation

193
00:09:27,091 --> 00:09:27,590
inverse.

194
00:09:27,590 --> 00:09:31,150


195
00:09:31,150 --> 00:09:34,920
So that's-- if I have
both of these properties,

196
00:09:34,920 --> 00:09:37,320
then partial
retroactivity is trivial.

197
00:09:37,320 --> 00:09:40,810
I just do everything
in the present.

198
00:09:40,810 --> 00:09:44,080
May not seem very exciting, but
it solves a bunch of problems

199
00:09:44,080 --> 00:09:45,370
already for free.

200
00:09:45,370 --> 00:09:48,220
So for example, hashing.

201
00:09:48,220 --> 00:09:51,654
If you want a dynamic
hash table or dictionary,

202
00:09:51,654 --> 00:09:53,820
and you want to be able to
make retroactive changes,

203
00:09:53,820 --> 00:09:56,236
it really doesn't matter whether
you make them in the past

204
00:09:56,236 --> 00:09:57,070
or in the present.

205
00:09:57,070 --> 00:10:00,130
I'm assuming a little bit here
that you don't, for example,

206
00:10:00,130 --> 00:10:03,070
clobber a key and write
to the same key twice.

207
00:10:03,070 --> 00:10:05,490
Then the order would matter.

208
00:10:05,490 --> 00:10:08,410
But if you store all copies of
all keys, then this is true.

209
00:10:08,410 --> 00:10:10,936


210
00:10:10,936 --> 00:10:12,310
Slightly more
interesting, if you

211
00:10:12,310 --> 00:10:21,250
have an array with the
operation add delta

212
00:10:21,250 --> 00:10:22,480
to a given array element.

213
00:10:22,480 --> 00:10:24,980
So if I had an assignment here,
then the order would matter.

214
00:10:24,980 --> 00:10:29,000
But if I have only
addition or subtraction,

215
00:10:29,000 --> 00:10:31,180
that's fine, because
addition and subtraction

216
00:10:31,180 --> 00:10:32,620
are commutative.

217
00:10:32,620 --> 00:10:34,690
So I can do that.

218
00:10:34,690 --> 00:10:37,792
Not terribly exciting,
as you might imagine.

219
00:10:37,792 --> 00:10:40,000
We're going to get to much
more interesting examples.

220
00:10:40,000 --> 00:10:44,950
But a natural question here is
what about full retroactivity?

221
00:10:44,950 --> 00:10:46,780
So partial's nice.

222
00:10:46,780 --> 00:10:48,991
But if I have such
an easy setup,

223
00:10:48,991 --> 00:10:50,365
can I achieve full
retroactivity?

224
00:10:50,365 --> 00:10:53,530
It's not so obvious because
now working in the present,

225
00:10:53,530 --> 00:10:57,130
it's not correctly
reflecting the past.

226
00:10:57,130 --> 00:10:59,170
To do that, we need--

227
00:10:59,170 --> 00:11:01,210
we cannot do it in
general, we don't know how.

228
00:11:01,210 --> 00:11:05,230
But there is a situation
where we do know how.

229
00:11:05,230 --> 00:11:07,285
First I'll define
a search problem.

230
00:11:07,285 --> 00:11:11,680


231
00:11:11,680 --> 00:11:14,080
The search problem is--

232
00:11:14,080 --> 00:11:16,880
you've seen many
examples of this

233
00:11:16,880 --> 00:11:19,460
in your algorithmic lifetime--

234
00:11:19,460 --> 00:11:22,960
I maintain a set S of objects--

235
00:11:22,960 --> 00:11:24,820
we don't know what they are--

236
00:11:24,820 --> 00:11:30,100
subject to insert, delete,
and some kind of search query.

237
00:11:30,100 --> 00:11:39,280


238
00:11:39,280 --> 00:11:42,250
And I want to focus in on the
types of queries we allow.

239
00:11:42,250 --> 00:11:45,940
So this in particular,
insert and delete

240
00:11:45,940 --> 00:11:47,770
are commutative and invertible.

241
00:11:47,770 --> 00:11:49,220
They are each other's inverses.

242
00:11:49,220 --> 00:11:52,220
So n queries are queries.

243
00:11:52,220 --> 00:11:54,190
This is really just a
constraint on updates.

244
00:11:54,190 --> 00:11:57,041
So search problems fall
into this easy class.

245
00:11:57,041 --> 00:11:58,540
So in particular,
it covers hashing.

246
00:11:58,540 --> 00:12:01,420


247
00:12:01,420 --> 00:12:04,570
Fine, that's a general
class of problems.

248
00:12:04,570 --> 00:12:07,990
Here's a slightly less
general class of problems,

249
00:12:07,990 --> 00:12:11,180
which are sort of well-studied.

250
00:12:11,180 --> 00:12:13,870
The old geometric data
structures literature.

251
00:12:13,870 --> 00:12:15,160
Decomposable search problems.

252
00:12:15,160 --> 00:12:17,810


253
00:12:17,810 --> 00:12:22,060
This is a concept
from 1980 revitalized.

254
00:12:22,060 --> 00:12:23,920
I should mention this
retroactive paper

255
00:12:23,920 --> 00:12:24,880
is pretty recent.

256
00:12:24,880 --> 00:12:29,412
I think the journal
version appeared in 2007.

257
00:12:29,412 --> 00:12:32,269
I have 2003 and 2007 here.

258
00:12:32,269 --> 00:12:34,060
So those are the two
versions of the paper.

259
00:12:34,060 --> 00:12:37,000


260
00:12:37,000 --> 00:12:40,640
So what's a decomposable
search problem?

261
00:12:40,640 --> 00:12:44,020
Same thing, but the query
is of a particular flavor,

262
00:12:44,020 --> 00:12:47,170
has a particular structure.

263
00:12:47,170 --> 00:12:52,560
If I want to do a query on the
union of two sets, a and b,

264
00:12:52,560 --> 00:12:55,480
it's the same thing as doing
the query on the two sets

265
00:12:55,480 --> 00:12:58,030
individually and then combining
them with some function.

266
00:12:58,030 --> 00:13:06,820


267
00:13:06,820 --> 00:13:10,717
This is a constraint
on what the query is.

268
00:13:10,717 --> 00:13:11,800
The problem is still this.

269
00:13:11,800 --> 00:13:14,290
I still want to do a
query on the entire set.

270
00:13:14,290 --> 00:13:18,220
But I just know this fact,
that if I could somehow

271
00:13:18,220 --> 00:13:19,930
solve the query
on smaller sets, I

272
00:13:19,930 --> 00:13:23,080
could combine them into the
union using this f function.

273
00:13:23,080 --> 00:13:25,510
For some, let's say this can
be computed in constant time.

274
00:13:25,510 --> 00:13:30,329


275
00:13:30,329 --> 00:13:31,870
That's a decomposable
search problem.

276
00:13:31,870 --> 00:13:35,492
For example, suppose I have
a set of points in the plane.

277
00:13:35,492 --> 00:13:37,450
And I want to know, given
a query point, what's

278
00:13:37,450 --> 00:13:39,160
the nearest point in my set?

279
00:13:39,160 --> 00:13:43,210
So it would be dynamic
nearest neighbor.

280
00:13:43,210 --> 00:13:46,090
If I could compute the nearest
neighbor among one subset

281
00:13:46,090 --> 00:13:47,140
of the points, and
the nearest neighbor

282
00:13:47,140 --> 00:13:49,660
among a different subset, I can
compute the nearest neighbor

283
00:13:49,660 --> 00:13:52,240
among the union just by
taking the min of the two.

284
00:13:52,240 --> 00:13:54,490
Doesn't matter whether
a and b overlap.

285
00:13:54,490 --> 00:13:56,650
That will still give
the right answer.

286
00:13:56,650 --> 00:13:58,720
Sort of a min over all things.

287
00:13:58,720 --> 00:14:02,140
I have some other examples.

288
00:14:02,140 --> 00:14:04,550
Successor on a line.

289
00:14:04,550 --> 00:14:06,220
If I'm given a
query point, I want

290
00:14:06,220 --> 00:14:09,190
to know what the next, the
nearest item after it is.

291
00:14:09,190 --> 00:14:12,850
That's sort of like
one-sided nearest neighbor.

292
00:14:12,850 --> 00:14:16,840
Yeah, point location, we'll
get to that in the future.

293
00:14:16,840 --> 00:14:18,590
Don't want to time
travel too much.

294
00:14:18,590 --> 00:14:22,760
OK, so some property-- some
queries have this property.

295
00:14:22,760 --> 00:14:23,260
Some don't.

296
00:14:23,260 --> 00:14:27,160
If they do-- and we have
commutative and invertability--

297
00:14:27,160 --> 00:14:30,010
I claim full retroactivity
becomes easy.

298
00:14:30,010 --> 00:14:31,030
Relatively easy.

299
00:14:31,030 --> 00:14:33,140
Log factor overhead.

300
00:14:33,140 --> 00:14:35,500
So that's what I
wanted to show you.

301
00:14:35,500 --> 00:14:38,170


302
00:14:38,170 --> 00:14:43,270
Full retro for decomposable
search problems.

303
00:14:43,270 --> 00:14:48,430


304
00:14:48,430 --> 00:14:50,470
Decomposable search
problems are automatically

305
00:14:50,470 --> 00:14:52,090
computed of an
invertible, so I don't

306
00:14:52,090 --> 00:14:54,410
need to write that constraint.

307
00:14:54,410 --> 00:15:01,110
In log-- I have n here,
but I think I mean m--

308
00:15:01,110 --> 00:15:01,610
overhead.

309
00:15:01,610 --> 00:15:04,370


310
00:15:04,370 --> 00:15:06,790
It's a multiplicative factor.

311
00:15:06,790 --> 00:15:09,089
m here is the number of
retroactive operations

312
00:15:09,089 --> 00:15:09,630
you're doing.

313
00:15:09,630 --> 00:15:11,606
So it's the size
of the timeline.

314
00:15:11,606 --> 00:15:15,080


315
00:15:15,080 --> 00:15:22,150
OK, we're going to do that
via something called a segment

316
00:15:22,150 --> 00:15:29,012
tree, which was introduced
in the same paper that

317
00:15:29,012 --> 00:15:31,470
dealt with decomposable search
problems by Bentley and Saxe

318
00:15:31,470 --> 00:15:34,450
in 1980.

319
00:15:34,450 --> 00:15:36,850
They weren't thinking
about time travel.

320
00:15:36,850 --> 00:15:40,450
Retroactively their
result is useful.

321
00:15:40,450 --> 00:15:44,080
So what's a segment tree?

322
00:15:44,080 --> 00:15:45,260
It's a tree.

323
00:15:45,260 --> 00:15:48,490
Let me draw my favorite picture.

324
00:15:48,490 --> 00:15:51,020
Draw this many times in
this class, I'm sure.

325
00:15:51,020 --> 00:15:55,330


326
00:15:55,330 --> 00:15:59,440
I would like to build a balanced
binary search tree on time.

327
00:15:59,440 --> 00:16:00,475
Leaves will be time.

328
00:16:00,475 --> 00:16:03,490


329
00:16:03,490 --> 00:16:04,015
Here's time.

330
00:16:04,015 --> 00:16:08,900


331
00:16:08,900 --> 00:16:12,969
And the idea is, well, if I
have my operations, my updates--

332
00:16:12,969 --> 00:16:15,010
which are what the things
that live on time are--

333
00:16:15,010 --> 00:16:17,090
are inserts and deletes.

334
00:16:17,090 --> 00:16:19,780
And so if I look at an
element, at some point

335
00:16:19,780 --> 00:16:20,890
it might be inserted.

336
00:16:20,890 --> 00:16:22,556
At some point later
it might be deleted.

337
00:16:22,556 --> 00:16:25,240
I'm going to assume every
element is inserted and deleted

338
00:16:25,240 --> 00:16:27,820
only once.

339
00:16:27,820 --> 00:16:29,660
Otherwise, if it
happens multiple times,

340
00:16:29,660 --> 00:16:31,910
think of them as
different elements.

341
00:16:31,910 --> 00:16:36,460
Then every element exists
for an interval of time.

342
00:16:36,460 --> 00:16:39,940
So for example, maybe
I have an element

343
00:16:39,940 --> 00:16:42,880
that exists for this
interval of time.

344
00:16:42,880 --> 00:16:46,960
Maybe it gets inserted here
and then gets deleted here.

345
00:16:46,960 --> 00:16:50,380
How should I represent
that interval in my tree?

346
00:16:50,380 --> 00:16:53,650
Let's call this element a.

347
00:16:53,650 --> 00:16:56,442
Well, if I draw a
complete binary tree,

348
00:16:56,442 --> 00:16:58,150
there there's an
obvious way to represent

349
00:16:58,150 --> 00:17:04,871
that interval, which is as the
union of these four intervals.

350
00:17:04,871 --> 00:17:06,579
If you think of this
node as representing

351
00:17:06,579 --> 00:17:08,750
the interval of
all of its leaves,

352
00:17:08,750 --> 00:17:11,140
descendant leaves, then
I could put a here.

353
00:17:11,140 --> 00:17:16,660
And I could put a here,
and here, and here.

354
00:17:16,660 --> 00:17:19,270
I do that for all my elements.

355
00:17:19,270 --> 00:17:21,640
This picture's going
to get messy quickly.

356
00:17:21,640 --> 00:17:24,599
Let me just do one more example.

357
00:17:24,599 --> 00:17:31,880
So maybe I have an
element from here to here.

358
00:17:31,880 --> 00:17:33,850
Then I'm going to
call that element b.

359
00:17:33,850 --> 00:17:36,010
Then I'll put b here.

360
00:17:36,010 --> 00:17:38,950
And I'll put b here.

361
00:17:38,950 --> 00:17:41,650
So always putting it
is as high as I can.

362
00:17:41,650 --> 00:17:44,330
I don't want to put b or a in
all the leaves it appears in,

363
00:17:44,330 --> 00:17:46,330
because that would be a
linear number of leaves.

364
00:17:46,330 --> 00:17:47,950
If I do it like
this, there's only

365
00:17:47,950 --> 00:17:50,560
log n subtrees I care
about, representing

366
00:17:50,560 --> 00:17:57,000
the interval as a union of log
n subtree aligned intervals.

367
00:17:57,000 --> 00:18:01,090
OK, now the real picture is
slightly messier than this.

368
00:18:01,090 --> 00:18:03,670
I drew a nice,
complete, perfect tree.

369
00:18:03,670 --> 00:18:06,677
In reality, you're inserting
new operations in here.

370
00:18:06,677 --> 00:18:08,260
And so you've actually
got to maintain

371
00:18:08,260 --> 00:18:09,843
this as a balanced
binary search tree.

372
00:18:09,843 --> 00:18:13,560
So use a red-black tree, AVL
tree, or pick your favorite.

373
00:18:13,560 --> 00:18:17,420
As long as it stays balanced,
you can still do this.

374
00:18:17,420 --> 00:18:19,870
It'll be a little less
obvious how to do rotations,

375
00:18:19,870 --> 00:18:22,660
but let's not worry about
rotations right now.

376
00:18:22,660 --> 00:18:25,150
Now I want to do a query.

377
00:18:25,150 --> 00:18:26,200
What's a query look like?

378
00:18:26,200 --> 00:18:28,300
Well, I care about
all the things done up

379
00:18:28,300 --> 00:18:29,170
to a certain time.

380
00:18:29,170 --> 00:18:31,990
Or really I care
about who exists.

381
00:18:31,990 --> 00:18:36,876
Let's say I want to do a
query on an array here.

382
00:18:36,876 --> 00:18:39,250
That's maybe not so exciting.

383
00:18:39,250 --> 00:18:43,060
Let's do a query here.

384
00:18:43,060 --> 00:18:46,090


385
00:18:46,090 --> 00:18:49,510
I want to know at
this time who exists,

386
00:18:49,510 --> 00:18:51,970
and perform the
query on that time.

387
00:18:51,970 --> 00:18:54,340
So really, I'm asking
about everything

388
00:18:54,340 --> 00:18:58,930
done in this interval,
from the beginning of time

389
00:18:58,930 --> 00:19:01,430
to my query time t.

390
00:19:01,430 --> 00:19:06,550
So here's query of t.

391
00:19:06,550 --> 00:19:08,500
Now we don't know
what the query is.

392
00:19:08,500 --> 00:19:10,380
We just know it's on the set.

393
00:19:10,380 --> 00:19:14,720
And we know that is decomposable
in this way by a set union.

394
00:19:14,720 --> 00:19:18,070
So the idea is, well I'll do the
query on this data structure,

395
00:19:18,070 --> 00:19:20,847
because that represents
whatever existed at that time.

396
00:19:20,847 --> 00:19:22,930
And then I'll do the query
on this data structure,

397
00:19:22,930 --> 00:19:24,555
because that represents
the things that

398
00:19:24,555 --> 00:19:25,930
existed before that.

399
00:19:25,930 --> 00:19:29,500


400
00:19:29,500 --> 00:19:32,240
That doesn't look so great.

401
00:19:32,240 --> 00:19:36,550
OK, so I need to put
each element in log n

402
00:19:36,550 --> 00:19:39,310
different nodes in
here, such that I

403
00:19:39,310 --> 00:19:42,280
can answer a query by looking
at log n different nodes.

404
00:19:42,280 --> 00:19:45,670
And a query is asking about
what are all the things that

405
00:19:45,670 --> 00:19:48,480
exist at this time.

406
00:19:48,480 --> 00:19:50,310
So here it would be ab.

407
00:19:50,310 --> 00:19:51,810
Over here it would be nothing.

408
00:19:51,810 --> 00:19:54,884
Over here it would be nothing.

409
00:19:54,884 --> 00:19:56,357
Yeah?

410
00:19:56,357 --> 00:19:58,812
AUDIENCE: If you're
querying, the time

411
00:19:58,812 --> 00:20:00,776
correspond to
particular [INAUDIBLE]..

412
00:20:00,776 --> 00:20:03,250
Then you can query all
the data structures--

413
00:20:03,250 --> 00:20:05,900
ERIK DEMAINE: OK, maybe I was
just doing the queries wrong.

414
00:20:05,900 --> 00:20:08,630
Good, I think
that's a good idea.

415
00:20:08,630 --> 00:20:12,080
I guess I'm asking about
querying this time.

416
00:20:12,080 --> 00:20:13,850
So which node should I do?

417
00:20:13,850 --> 00:20:15,350
All the ancestors.

418
00:20:15,350 --> 00:20:19,630


419
00:20:19,630 --> 00:20:21,920
I see.

420
00:20:21,920 --> 00:20:24,880
Claim that does it.

421
00:20:24,880 --> 00:20:25,962
Gotta think about it.

422
00:20:25,962 --> 00:20:29,609
AUDIENCE: And then
you carry [INAUDIBLE]

423
00:20:29,609 --> 00:20:31,400
ERIK DEMAINE: That
definitely gets a and b.

424
00:20:31,400 --> 00:20:32,260
That looks good.

425
00:20:32,260 --> 00:20:34,180
All right, exercise to
prove that this works.

426
00:20:34,180 --> 00:20:38,110


427
00:20:38,110 --> 00:20:40,150
I think that is right.

428
00:20:40,150 --> 00:20:42,640
So it's an asymmetry
between queries and updates.

429
00:20:42,640 --> 00:20:48,550
For updates, you basically
partition the interval.

430
00:20:48,550 --> 00:20:51,340


431
00:20:51,340 --> 00:20:54,784
AUDIENCE: What happens to
a very short-lived element

432
00:20:54,784 --> 00:20:57,736
at the very end of
the time travel?

433
00:20:57,736 --> 00:21:13,030
[INAUDIBLE]

434
00:21:13,030 --> 00:21:14,530
ERIK DEMAINE: So
maybe this works.

435
00:21:14,530 --> 00:21:16,630
I'll think about
it offline and I'll

436
00:21:16,630 --> 00:21:18,580
send email if it doesn't work.

437
00:21:18,580 --> 00:21:21,670
But I think this is right.

438
00:21:21,670 --> 00:21:23,320
So for query, you walk up time.

439
00:21:23,320 --> 00:21:25,990
And I'm going to query each
of these data structures.

440
00:21:25,990 --> 00:21:28,270
Now this is a logarithmic
factor overhead,

441
00:21:28,270 --> 00:21:32,230
both in time and space, because
each element might be stored

442
00:21:32,230 --> 00:21:33,480
in log n different structures.

443
00:21:33,480 --> 00:21:35,510
Or what are in these
nodes, by the way?

444
00:21:35,510 --> 00:21:38,535
That is your data structure,
the non-retroactive version.

445
00:21:38,535 --> 00:21:40,660
So we're storing the
non-radioactive data structure

446
00:21:40,660 --> 00:21:43,935
on these guys in order to--

447
00:21:43,935 --> 00:21:46,990
when I add-- if I
modify a's interval,

448
00:21:46,990 --> 00:21:48,490
I delete it from
all the places that

449
00:21:48,490 --> 00:21:51,340
used to be in and then
reinsert it into all the places

450
00:21:51,340 --> 00:21:51,940
it's now in.

451
00:21:51,940 --> 00:21:54,520
So I'm doing inserts
and deletes on log n

452
00:21:54,520 --> 00:21:58,330
of those non-retroactive
data structures.

453
00:21:58,330 --> 00:22:01,490
OK, and then I combine with
f which is constant time.

454
00:22:01,490 --> 00:22:05,211
So only log factor
overhead on the queries.

455
00:22:05,211 --> 00:22:07,390
OK, a little harder
than I thought.

456
00:22:07,390 --> 00:22:10,420


457
00:22:10,420 --> 00:22:13,300
So full retro,
full retroactivity,

458
00:22:13,300 --> 00:22:16,324
but in this relatively
simple special case.

459
00:22:16,324 --> 00:22:17,740
Let's talk about
the general case.

460
00:22:17,740 --> 00:22:37,630


461
00:22:37,630 --> 00:22:42,830
There's an obvious way to do
full retroactivity, which is--

462
00:22:42,830 --> 00:22:44,200
let's say partial retroactivity.

463
00:22:44,200 --> 00:22:46,780
I want to know what
happened in the present.

464
00:22:46,780 --> 00:22:51,280
The obvious thing to do is write
down all the changes you made.

465
00:22:51,280 --> 00:22:53,800
And then if you want to
make a retroactive change,

466
00:22:53,800 --> 00:22:57,580
you roll back, do your change,
and then replay everything

467
00:22:57,580 --> 00:22:59,200
that happened meanwhile.

468
00:22:59,200 --> 00:23:01,660
So this is the rollback method.

469
00:23:01,660 --> 00:23:25,470


470
00:23:25,470 --> 00:23:31,450
So if I need to go back in time
by a factor of r, by r time

471
00:23:31,450 --> 00:23:34,930
units, I pay a factor
of r overhead in time.

472
00:23:34,930 --> 00:23:36,010
And space is reasonable.

473
00:23:36,010 --> 00:23:39,670
You just have to remember
everything that happened.

474
00:23:39,670 --> 00:23:41,340
This is pretty obvious.

475
00:23:41,340 --> 00:23:42,784
Also old.

476
00:23:42,784 --> 00:23:44,200
Unfortunately,
it's about the best

477
00:23:44,200 --> 00:23:47,800
we can do in general,
depending on your exact model.

478
00:23:47,800 --> 00:23:54,492


479
00:23:54,492 --> 00:23:55,670
So we add the lower bound.

480
00:23:55,670 --> 00:24:14,210


481
00:24:14,210 --> 00:24:17,900
This is kind of a fun result
from a philosophy standpoint,

482
00:24:17,900 --> 00:24:20,142
philosophy of time travel.

483
00:24:20,142 --> 00:24:22,100
It's essentially saying
that Back to the Future

484
00:24:22,100 --> 00:24:23,360
is impossible.

485
00:24:23,360 --> 00:24:25,610
I know, it's sad but true.

486
00:24:25,610 --> 00:24:28,850
And there's a good movie
about this called Retroactive.

487
00:24:28,850 --> 00:24:31,760
This is a very unknown
movie, from '97,

488
00:24:31,760 --> 00:24:37,667
or so, where they play through
this sequence of events.

489
00:24:37,667 --> 00:24:39,750
And then there's a time
machine which brings them,

490
00:24:39,750 --> 00:24:42,740
I forget, an hour into the past.

491
00:24:42,740 --> 00:24:44,510
And then they have to
relive those events.

492
00:24:44,510 --> 00:24:45,882
And they can make changes.

493
00:24:45,882 --> 00:24:47,840
But they have to spend
all that time until they

494
00:24:47,840 --> 00:24:48,830
get to the time machine again.

495
00:24:48,830 --> 00:24:51,290
They still didn't get it
right, so they go back in time.

496
00:24:51,290 --> 00:24:54,140
And the movie repeats
like six times or so,

497
00:24:54,140 --> 00:24:55,660
until they finally get it right.

498
00:24:55,660 --> 00:24:59,030
Or I shouldn't, whatever,
forget the ending actually.

499
00:24:59,030 --> 00:25:03,020
So that's realistic in that
we know from persistence,

500
00:25:03,020 --> 00:25:05,150
we can remember the past.

501
00:25:05,150 --> 00:25:08,360
And we can jump back into the
past and then just relive it.

502
00:25:08,360 --> 00:25:10,610
And maybe make
changes along the way.

503
00:25:10,610 --> 00:25:13,520
But the claim is you can't
do that any more efficiently

504
00:25:13,520 --> 00:25:16,670
than replaying all of those
events, in the worst case,

505
00:25:16,670 --> 00:25:19,760
and I think even in real life.

506
00:25:19,760 --> 00:25:21,300
Should include the worst case.

507
00:25:21,300 --> 00:25:22,460
So let me tell you why.

508
00:25:22,460 --> 00:25:24,920
All we need to live
in our universe

509
00:25:24,920 --> 00:25:28,460
for this lower bound to hold
is a very simple computer.

510
00:25:28,460 --> 00:25:41,440


511
00:25:41,440 --> 00:25:44,360
It's a computer with
two registers, x and y.

512
00:25:44,360 --> 00:25:45,530
They start at zero.

513
00:25:45,530 --> 00:25:46,520
AUDIENCE: Question.

514
00:25:46,520 --> 00:25:46,745
ERIK DEMAINE: Yeah?

515
00:25:46,745 --> 00:25:49,161
AUDIENCE: When you say that
the overhead can be necessary,

516
00:25:49,161 --> 00:25:51,520
does that mean that
it's sometimes not--

517
00:25:51,520 --> 00:25:54,194
ERIK DEMAINE: The can be is
relative to the data structure.

518
00:25:54,194 --> 00:25:55,610
So there is a data
structure where

519
00:25:55,610 --> 00:26:01,430
you're guaranteed to need
order r in the worst case.

520
00:26:01,430 --> 00:26:04,804
And probably the average case
in all sorts of bad things.

521
00:26:04,804 --> 00:26:06,470
Yeah, so there are
some data structures,

522
00:26:06,470 --> 00:26:09,780
like these ones, where
you can do better.

523
00:26:09,780 --> 00:26:13,564
And this is for
partial retroactivity.

524
00:26:13,564 --> 00:26:15,230
But then there are
some data structures,

525
00:26:15,230 --> 00:26:16,670
like the one I'm going
to describe to you,

526
00:26:16,670 --> 00:26:17,780
that you cannot do better.

527
00:26:17,780 --> 00:26:21,707


528
00:26:21,707 --> 00:26:22,790
So here are my operations.

529
00:26:22,790 --> 00:26:25,230
I can set x to a value.

530
00:26:25,230 --> 00:26:29,600
I can add a value to y.

531
00:26:29,600 --> 00:26:35,240
I can compute the product of
x and y and put it into y.

532
00:26:35,240 --> 00:26:41,350
And then I have a query,
which is what is y.

533
00:26:41,350 --> 00:26:45,160
So this is one of the simplest
computers ever designed.

534
00:26:45,160 --> 00:26:47,210
A very basic calculator.

535
00:26:47,210 --> 00:26:51,230
But it lets us do--

536
00:26:51,230 --> 00:26:53,390
Here's what the operations
I'm going to do.

537
00:26:53,390 --> 00:26:57,890
First operation-- this
is in order of time.

538
00:26:57,890 --> 00:27:01,220
First I will add a into y.

539
00:27:01,220 --> 00:27:04,420
Then I will compute the product.

540
00:27:04,420 --> 00:27:06,220
Then I will compute--

541
00:27:06,220 --> 00:27:08,675
then I will add a
and minus 1 to y.

542
00:27:08,675 --> 00:27:11,900
Then I will compute the product.

543
00:27:11,900 --> 00:27:16,671
And then at the end, I
will add a zero to y.

544
00:27:16,671 --> 00:27:17,420
What does that do?

545
00:27:17,420 --> 00:27:21,090


546
00:27:21,090 --> 00:27:22,724
Mathematicians.

547
00:27:22,724 --> 00:27:24,890
AUDIENCE: [INAUDIBLE]

548
00:27:24,890 --> 00:27:27,470
ERIK DEMAINE:
Polynomial evaluation.

549
00:27:27,470 --> 00:27:34,650
This is equivalent to
computing a n, x to the n--

550
00:27:34,650 --> 00:27:38,780
well, I guess capital X
to the n, a n minus 1,

551
00:27:38,780 --> 00:27:41,655
x to the n minus 1, a0.

552
00:27:41,655 --> 00:27:44,210


553
00:27:44,210 --> 00:27:46,040
OK, I didn't set X
at the beginning.

554
00:27:46,040 --> 00:27:49,400
But whatever X was, this
sequence of operations

555
00:27:49,400 --> 00:27:50,820
will evaluate this polynomial.

556
00:27:50,820 --> 00:27:53,870
This is called Cramer's rule
for evaluating that polynomial.

557
00:27:53,870 --> 00:27:56,660
Just keep multiplying
by X in each round,

558
00:27:56,660 --> 00:28:00,130
adding on the next coefficient.

559
00:28:00,130 --> 00:28:01,760
OK, so the result--

560
00:28:01,760 --> 00:28:03,950
this I'm just going to
do at the beginning.

561
00:28:03,950 --> 00:28:06,020
It's like regular operations.

562
00:28:06,020 --> 00:28:13,250
And now I'm going to do
things like insert at time 0

563
00:28:13,250 --> 00:28:17,490
that X equals some value.

564
00:28:17,490 --> 00:28:18,560
I'm just going to keep--

565
00:28:18,560 --> 00:28:21,310
first I'll put it here, then
right after, then right after--

566
00:28:21,310 --> 00:28:22,580
keep doing those insertions.

567
00:28:22,580 --> 00:28:24,740
I completely change what X is.

568
00:28:24,740 --> 00:28:28,310
And so I change where I'm
evaluating this polynomial.

569
00:28:28,310 --> 00:28:30,950
And claim is you
really can't do that

570
00:28:30,950 --> 00:28:33,740
any faster than
reevaluating the polynomial.

571
00:28:33,740 --> 00:28:45,630
In a history independent
algebraic decision tree model--

572
00:28:45,630 --> 00:28:51,830
which I don't want to
define precisely, but maybe

573
00:28:51,830 --> 00:28:53,720
computation tree
would be better.

574
00:28:53,720 --> 00:28:57,740
Anyway, this is just you draw a
tree of all the possible things

575
00:28:57,740 --> 00:28:59,400
you could do.

576
00:28:59,400 --> 00:29:02,750
And the things you can do are
additions, multiplications,

577
00:29:02,750 --> 00:29:07,690
subtractions, divisions,
all field operations.

578
00:29:07,690 --> 00:29:13,550
So for any field, this would
work with reals, would also,

579
00:29:13,550 --> 00:29:17,990
should work for
integers module LP.

580
00:29:17,990 --> 00:29:20,690
Any fields.

581
00:29:20,690 --> 00:29:25,910
And the interesting part is
independent of preprocessing

582
00:29:25,910 --> 00:29:29,090
of the coefficients, you can
stare at those coefficients

583
00:29:29,090 --> 00:29:31,040
however long you like.

584
00:29:31,040 --> 00:29:40,190
In the worst case, you need
mega n field operations,

585
00:29:40,190 --> 00:29:43,380
where n is the degree
of the polynomial.

586
00:29:43,380 --> 00:29:46,220
So this is a known
result from 2001.

587
00:29:46,220 --> 00:29:49,780
And so it tells you that each
of these retroactive operations,

588
00:29:49,780 --> 00:29:51,380
it's n time units in the past.

589
00:29:51,380 --> 00:29:53,600
And you need order n
time to complete it.

590
00:29:53,600 --> 00:29:55,550
Even though these
operations can be

591
00:29:55,550 --> 00:29:58,130
solved in constant time each.

592
00:29:58,130 --> 00:30:01,360
So it's a factor n loss.

593
00:30:01,360 --> 00:30:04,300
Now this is a particular
model of computation.

594
00:30:04,300 --> 00:30:06,970
It implies something like an
integer or a random access

595
00:30:06,970 --> 00:30:10,120
machine, where you can have
arrays, I don't really care.

596
00:30:10,120 --> 00:30:11,920
But as long as the
way that you're

597
00:30:11,920 --> 00:30:14,950
manipulating these objects
are with field operations,

598
00:30:14,950 --> 00:30:17,470
you're in trouble.

599
00:30:17,470 --> 00:30:19,990
OK, but there are conceivably
other things you could do.

600
00:30:19,990 --> 00:30:23,170


601
00:30:23,170 --> 00:30:24,880
If these numbers
are integers maybe

602
00:30:24,880 --> 00:30:26,800
I could split their
bits into parts

603
00:30:26,800 --> 00:30:28,294
and do crazy things with them.

604
00:30:28,294 --> 00:30:30,460
That's something we'll get
to later on in the class.

605
00:30:30,460 --> 00:30:33,970


606
00:30:33,970 --> 00:30:37,654
Even then, you can't do so well.

607
00:30:37,654 --> 00:30:42,122
I guess I'll briefly tell
you this because there's

608
00:30:42,122 --> 00:30:43,330
an interesting lower balance.

609
00:30:43,330 --> 00:30:44,860
Oh sorry, interesting
open problem.

610
00:30:44,860 --> 00:30:55,140


611
00:30:55,140 --> 00:30:58,720
Cell-probe model, something
we'll get into in a deeper way

612
00:30:58,720 --> 00:30:59,900
later on in this class.

613
00:30:59,900 --> 00:31:04,462
But it just says
how many objects,

614
00:31:04,462 --> 00:31:06,670
how many words of memory do
you need to read in order

615
00:31:06,670 --> 00:31:08,660
to solve your problem?

616
00:31:08,660 --> 00:31:10,930
So that's a lower bound on time.

617
00:31:10,930 --> 00:31:13,420
No matter how you're
computing with those numbers,

618
00:31:13,420 --> 00:31:15,790
how many of the objects,
how many of the integers

619
00:31:15,790 --> 00:31:17,727
do you need to read?

620
00:31:17,727 --> 00:31:19,810
Not necessarily just the
ai's You could split them

621
00:31:19,810 --> 00:31:22,420
into parts, do all
kinds of preprocessing,

622
00:31:22,420 --> 00:31:24,121
make a hash table,
build whatever

623
00:31:24,121 --> 00:31:25,120
data structure you want.

624
00:31:25,120 --> 00:31:29,050
How many words of that data
structure do you need to read?

625
00:31:29,050 --> 00:31:35,990
And the claim is at least square
root of r divided by log r.

626
00:31:35,990 --> 00:31:39,490
So roughly square root
of r, open problem,

627
00:31:39,490 --> 00:31:44,030
is can you get something
like r again in this model?

628
00:31:44,030 --> 00:31:47,169
So this is a very powerful
model, not at all realistic.

629
00:31:47,169 --> 00:31:49,210
But if you can prove a
lower bound in this model,

630
00:31:49,210 --> 00:31:53,530
then it holds basically all
models you could ever think of.

631
00:31:53,530 --> 00:31:55,570
So here's a data
structure-- or here's

632
00:31:55,570 --> 00:31:57,790
the proof of this lower bound.

633
00:31:57,790 --> 00:32:01,420


634
00:32:01,420 --> 00:32:03,770
Data structure
maintains n words.

635
00:32:03,770 --> 00:32:06,359


636
00:32:06,359 --> 00:32:07,900
I should say typically
in this class,

637
00:32:07,900 --> 00:32:14,460
a word is an integer
of let's say log n--

638
00:32:14,460 --> 00:32:15,790
I'll be more precise.

639
00:32:15,790 --> 00:32:17,650
w bits.

640
00:32:17,650 --> 00:32:18,880
w is at least log n.

641
00:32:18,880 --> 00:32:21,580


642
00:32:21,580 --> 00:32:23,170
We'll talk about
this a lot more later

643
00:32:23,170 --> 00:32:26,390
in the class when we get
to integer data structures.

644
00:32:26,390 --> 00:32:30,850
But if you were wondering what
a word means, there it is.

645
00:32:30,850 --> 00:32:34,240
And the operations, the
updates you are allowed to do

646
00:32:34,240 --> 00:32:37,520
are arithmetic operations.

647
00:32:37,520 --> 00:32:40,450
So it's generalization
of this problem.

648
00:32:40,450 --> 00:32:43,540
You can do addition,
multiplication, division,

649
00:32:43,540 --> 00:32:46,341
just basic stuff.

650
00:32:46,341 --> 00:32:48,340
So that's the data structure
we're trying to do.

651
00:32:48,340 --> 00:32:52,420
And at the end you can query
what is the value of this word.

652
00:32:52,420 --> 00:32:54,910
And now what are we going to do?

653
00:32:54,910 --> 00:32:57,850
Before we did polynomial
evaluation in that model.

654
00:32:57,850 --> 00:33:01,660
Now what I'm going to
do is compute FFT, fast

655
00:33:01,660 --> 00:33:03,710
Fourier transform.

656
00:33:03,710 --> 00:33:05,180
If you know how
to do that great.

657
00:33:05,180 --> 00:33:07,510
If not, it's an n
log n algorithm.

658
00:33:07,510 --> 00:33:09,280
So it's an n log in
operations you do.

659
00:33:09,280 --> 00:33:12,200
I'm just going to write them
down as my sequence of updates.

660
00:33:12,200 --> 00:33:15,340
At the end I have the
fast Fourier transform.

661
00:33:15,340 --> 00:33:18,280
And the retroactive
thing I'm going to do

662
00:33:18,280 --> 00:33:23,230
is set all of these words,
all the xi's, and name them.

663
00:33:23,230 --> 00:33:25,780
Which changes the input to
the fast Fourier transform.

664
00:33:25,780 --> 00:33:32,200
And it turns out that dynamic
fast Fourier transform,

665
00:33:32,200 --> 00:33:41,440
where changing one of the
words, xi, you can show,

666
00:33:41,440 --> 00:33:43,360
or it has been shown--

667
00:33:43,360 --> 00:33:45,190
we're not going to
prove this here--

668
00:33:45,190 --> 00:33:49,540
requires at least square
root of n cell-probes.

669
00:33:49,540 --> 00:33:52,540


670
00:33:52,540 --> 00:33:53,674
So this is about--

671
00:33:53,674 --> 00:33:55,840
if you change one thing in
a fast Fourier transform,

672
00:33:55,840 --> 00:33:58,630
it doesn't change
everything, necessarily.

673
00:33:58,630 --> 00:34:01,330
But the claim is
that you need to look

674
00:34:01,330 --> 00:34:03,220
at least root n of
the things again,

675
00:34:03,220 --> 00:34:06,820
in order to figure out what
happened, how the FFT changed.

676
00:34:06,820 --> 00:34:09,610
So I mention this mostly
as an interesting question

677
00:34:09,610 --> 00:34:12,310
of whether you can come up
with a better lower bound

678
00:34:12,310 --> 00:34:13,750
in this data structure.

679
00:34:13,750 --> 00:34:16,030
Ideally taking some
existing lower bound,

680
00:34:16,030 --> 00:34:20,469
plugging it in to this kind
of retroactive framework,

681
00:34:20,469 --> 00:34:25,739
and getting what you want.

682
00:34:25,739 --> 00:34:27,310
Enough about the bad news.

683
00:34:27,310 --> 00:34:31,040
I want to go to
positive results again.

684
00:34:31,040 --> 00:34:33,520
So we had a very
simple thing here.

685
00:34:33,520 --> 00:34:35,020
Let's try something
that's somewhere

686
00:34:35,020 --> 00:34:38,980
in between, where there
are chain reactions,

687
00:34:38,980 --> 00:34:40,612
but it's not impossible.

688
00:34:40,612 --> 00:34:42,070
So in general, if
you're building--

689
00:34:42,070 --> 00:34:44,445
if you have a data structure
that represents an arbitrary

690
00:34:44,445 --> 00:34:46,594
computer, you're
basically hosed.

691
00:34:46,594 --> 00:34:48,010
If you have a data
structure where

692
00:34:48,010 --> 00:34:50,949
the operations can be
arbitrarily reordered, pretty

693
00:34:50,949 --> 00:34:51,699
easy.

694
00:34:51,699 --> 00:34:59,920
So our intermediate setting will
be priority queues, the example

695
00:34:59,920 --> 00:35:01,618
I showed at the very beginning.

696
00:35:01,618 --> 00:35:10,250


697
00:35:10,250 --> 00:35:11,920
So on a priority
queue, I'm going

698
00:35:11,920 --> 00:35:15,836
to think about two operations,
insert and delete-min.

699
00:35:15,836 --> 00:35:19,240


700
00:35:19,240 --> 00:35:22,480
This is interesting
because delete-min depends

701
00:35:22,480 --> 00:35:25,750
on what the current state is.

702
00:35:25,750 --> 00:35:27,760
So if I insert
something early on,

703
00:35:27,760 --> 00:35:30,730
it can change every delete-min
that happens thereafter,

704
00:35:30,730 --> 00:35:34,120
and completely change what
happens at the end of the data

705
00:35:34,120 --> 00:35:36,820
structure.

706
00:35:36,820 --> 00:35:38,350
So the claim is
we can solve this

707
00:35:38,350 --> 00:35:46,030
with log n time per
operation, per partially

708
00:35:46,030 --> 00:35:47,727
retroactive operation.

709
00:35:47,727 --> 00:35:51,710


710
00:35:51,710 --> 00:35:57,125
It's pretty good because
in this model, which--

711
00:35:57,125 --> 00:35:58,910
what model are we in here?

712
00:35:58,910 --> 00:36:02,430
I guess pointer machine
would be a reasonable model?

713
00:36:02,430 --> 00:36:05,540
Log n is the best you can
hope for a priority queue.

714
00:36:05,540 --> 00:36:08,560
I guess comparison model
is more relevant then.

715
00:36:08,560 --> 00:36:10,290
So you can use priority
queues to sort.

716
00:36:10,290 --> 00:36:13,340
So log n is the best you can
do for regular priority queues.

717
00:36:13,340 --> 00:36:16,460
And so to do it also
partially retroactive

718
00:36:16,460 --> 00:36:19,460
is pretty interesting.

719
00:36:19,460 --> 00:36:22,260
How do we do this?

720
00:36:22,260 --> 00:36:25,730
Well, I don't want to draw
a picture of what these data

721
00:36:25,730 --> 00:36:26,660
structures look like.

722
00:36:26,660 --> 00:36:33,230


723
00:36:33,230 --> 00:36:38,630
My picture is keyspace is
going to be the y-axis,

724
00:36:38,630 --> 00:36:40,730
and time is the x-axis.

725
00:36:40,730 --> 00:36:43,410


726
00:36:43,410 --> 00:36:45,620
So if someone comes along
and does an insertion,

727
00:36:45,620 --> 00:36:49,916
they do the insertion at some
time with some key value.

728
00:36:49,916 --> 00:36:51,290
And so I'm going
to think of that

729
00:36:51,290 --> 00:36:53,373
as a rightward pointing
ray, because at that point

730
00:36:53,373 --> 00:36:55,940
that element exists.

731
00:36:55,940 --> 00:36:59,690
And if nothing happens, it
will exist for the end of time.

732
00:36:59,690 --> 00:37:02,030
The problem would be if
someone comes along and does

733
00:37:02,030 --> 00:37:02,790
a delete-min.

734
00:37:02,790 --> 00:37:08,004
A delete-min is going to be a
ray shooting up from infinity,

735
00:37:08,004 --> 00:37:09,920
because you always want
to delete the smallest

736
00:37:09,920 --> 00:37:10,880
possible thing.

737
00:37:10,880 --> 00:37:12,920
So whatever this
ray hits first, that

738
00:37:12,920 --> 00:37:15,440
is the thing that gets deleted.

739
00:37:15,440 --> 00:37:16,250
So I want to keep--

740
00:37:16,250 --> 00:37:19,530
I want to draw all those
rays for the delete-mins.

741
00:37:19,530 --> 00:37:21,330
So this is a delete-min.

742
00:37:21,330 --> 00:37:24,460


743
00:37:24,460 --> 00:37:27,410
And this is an insert.

744
00:37:27,410 --> 00:37:30,359
So I have rightward
rays for insertions.

745
00:37:30,359 --> 00:37:31,400
They start at some point.

746
00:37:31,400 --> 00:37:34,460
And I have upward
rays from infinity.

747
00:37:34,460 --> 00:37:37,400
In general, I'm going to
get a bunch of L shapes.

748
00:37:37,400 --> 00:37:52,010


749
00:37:52,010 --> 00:37:55,400
And the L's will be non
crossing in a legitimate picture

750
00:37:55,400 --> 00:37:58,532
of an execution
of the algorithm.

751
00:37:58,532 --> 00:38:01,380
AUDIENCE: The vertical stuff is
when you're taking the min out?

752
00:38:01,380 --> 00:38:03,830
ERIK DEMAINE: Yeah the
vertical lines are delete-mins.

753
00:38:03,830 --> 00:38:05,494
They're coming from below.

754
00:38:05,494 --> 00:38:07,910
They're taking whatever the
smallest thing is that exists.

755
00:38:07,910 --> 00:38:10,760
So think about like
this time right here.

756
00:38:10,760 --> 00:38:13,980
Right now these four elements
are in the data structure.

757
00:38:13,980 --> 00:38:16,400
You do a delete-min, you
delete the smallest one.

758
00:38:16,400 --> 00:38:18,150
So this guy dies.

759
00:38:18,150 --> 00:38:19,760
But the three others continue.

760
00:38:19,760 --> 00:38:22,800
Maybe there'll be some
elements that just exist.

761
00:38:22,800 --> 00:38:24,110
They don't get deleted.

762
00:38:24,110 --> 00:38:25,490
So it's not entirely L's.

763
00:38:25,490 --> 00:38:28,370
That's sort of a
half of an L. So you

764
00:38:28,370 --> 00:38:30,950
might have some L's like that
that just go off to infinity.

765
00:38:30,950 --> 00:38:33,770


766
00:38:33,770 --> 00:38:35,850
But everyone that's
in an L, this

767
00:38:35,850 --> 00:38:37,100
is the insertion that made it.

768
00:38:37,100 --> 00:38:39,014
These are the delete-mins
that deleted it.

769
00:38:39,014 --> 00:38:41,430
We're not going to do arbitrary
deletes, just delete-mins.

770
00:38:41,430 --> 00:38:44,110
It's hard enough.

771
00:38:44,110 --> 00:38:46,380
OK, problem clear?

772
00:38:46,380 --> 00:38:48,800
So I want to maintain this.

773
00:38:48,800 --> 00:38:55,850
Let me show you what goes wrong,
the hard part about this data

774
00:38:55,850 --> 00:38:57,680
structure.

775
00:38:57,680 --> 00:39:02,660
Let's say I do an insert here.

776
00:39:02,660 --> 00:39:04,100
New insertion.

777
00:39:04,100 --> 00:39:06,650
Well, that means that this
delete-min would have returned

778
00:39:06,650 --> 00:39:08,420
this guy instead of this one.

779
00:39:08,420 --> 00:39:11,141
So this one would actually
continue to exist.

780
00:39:11,141 --> 00:39:12,890
So then this delete-min
would have deleted

781
00:39:12,890 --> 00:39:15,110
this guy instead of that one.

782
00:39:15,110 --> 00:39:17,070
So this guy continues to exist.

783
00:39:17,070 --> 00:39:20,710
So this continues to the right.

784
00:39:20,710 --> 00:39:22,920
This starts exist
until this delete-min,

785
00:39:22,920 --> 00:39:24,870
and now this one exists.

786
00:39:24,870 --> 00:39:28,370
OK, and then this one
exists for the rest of time.

787
00:39:28,370 --> 00:39:31,640
In general, you do a
single retroactive insert,

788
00:39:31,640 --> 00:39:33,280
everything could change.

789
00:39:33,280 --> 00:39:35,510
Or a linear number
of guys could change.

790
00:39:35,510 --> 00:39:39,302


791
00:39:39,302 --> 00:39:41,760
So if you want to maintain this
picture, you're in trouble.

792
00:39:41,760 --> 00:39:44,187
You get an omega r lower bound.

793
00:39:44,187 --> 00:39:46,020
So we're not going to
maintain this picture.

794
00:39:46,020 --> 00:39:47,686
But we're going to
keep it in our minds,

795
00:39:47,686 --> 00:39:51,030
vaguely, that we wanted to know
something like this picture.

796
00:39:51,030 --> 00:39:53,940
What we really need to know
is that this element now

797
00:39:53,940 --> 00:39:55,845
exists in the data structure.

798
00:39:55,845 --> 00:39:57,720
If I'm just doing partial
retroactivity, what

799
00:39:57,720 --> 00:40:01,120
I care about is who
exists at the end of time.

800
00:40:01,120 --> 00:40:04,500
So I'm doing an insert
at a given time t,

801
00:40:04,500 --> 00:40:08,290
with a given key x.

802
00:40:08,290 --> 00:40:11,840
And if life was good, you
know, if I was commutative,

803
00:40:11,840 --> 00:40:13,590
then that would be
equivalent to inserting

804
00:40:13,590 --> 00:40:15,130
that key x at the end of time.

805
00:40:15,130 --> 00:40:16,080
But it's not.

806
00:40:16,080 --> 00:40:17,550
Instead I have to
figure out what

807
00:40:17,550 --> 00:40:19,740
key gets inserted
at the end when

808
00:40:19,740 --> 00:40:21,450
I insert this key at this time.

809
00:40:21,450 --> 00:40:24,200
And similarly for
adding a delete-min.

810
00:40:24,200 --> 00:40:26,520
I won't try to draw that,
but exactly the same kind

811
00:40:26,520 --> 00:40:29,680
of chain reactions can happen.

812
00:40:29,680 --> 00:40:32,610
OK, so we're going to
do this in log n time.

813
00:40:32,610 --> 00:40:53,850


814
00:40:53,850 --> 00:40:54,960
How do we do it?

815
00:40:54,960 --> 00:41:01,130


816
00:41:01,130 --> 00:41:04,910
So I'm going to focus on the
insertion case, inserting--

817
00:41:04,910 --> 00:41:06,440
the double insertion case--

818
00:41:06,440 --> 00:41:09,166
inserting an insert operation.

819
00:41:09,166 --> 00:41:11,540
I guess I'm going to switch
notation and call the keys k,

820
00:41:11,540 --> 00:41:12,590
instead of x.

821
00:41:12,590 --> 00:41:13,340
It doesn't matter.

822
00:41:13,340 --> 00:41:22,440


823
00:41:22,440 --> 00:41:24,200
OK, what I'd like
to know is that when

824
00:41:24,200 --> 00:41:28,712
I do this insertion, what gets
inserted into the final Q?

825
00:41:28,712 --> 00:41:30,170
I'm going to call
that Q now, being

826
00:41:30,170 --> 00:41:33,820
the the present, the future,
whatever you want to call it.

827
00:41:33,820 --> 00:41:36,620


828
00:41:36,620 --> 00:41:46,245
I claim this is
what gets inserted.

829
00:41:46,245 --> 00:41:53,530


830
00:41:53,530 --> 00:41:55,905
If you look at all the keys
that get deleted from now on,

831
00:41:55,905 --> 00:41:57,613
and you look at the
key you're inserting,

832
00:41:57,613 --> 00:41:59,100
you take the max
of all those, that

833
00:41:59,100 --> 00:42:00,960
will be the one that survives.

834
00:42:00,960 --> 00:42:02,640
That's pretty obvious.

835
00:42:02,640 --> 00:42:06,150
The annoying thing is this is
really hard to think about.

836
00:42:06,150 --> 00:42:08,730
Because who gets deleted
is something that

837
00:42:08,730 --> 00:42:10,560
is a chain reaction effect.

838
00:42:10,560 --> 00:42:13,134
What we'd really like to have
is the word inserted there,

839
00:42:13,134 --> 00:42:15,050
because we know what
things get inserted when.

840
00:42:15,050 --> 00:42:16,091
Those are the operations.

841
00:42:16,091 --> 00:42:18,700
We just maintain the list of
operations, we'd know that.

842
00:42:18,700 --> 00:42:21,510
Deleted is a lot
harder to think about.

843
00:42:21,510 --> 00:42:25,290
So we need a Lemma
that tells us--

844
00:42:25,290 --> 00:42:29,160
there's a nice equation that
simplifies this formula for us,

845
00:42:29,160 --> 00:42:31,030
or this computation.

846
00:42:31,030 --> 00:42:34,270
For that we need the
notion of a bridge.

847
00:42:34,270 --> 00:42:37,770
A very simple idea.

848
00:42:37,770 --> 00:42:45,150
A bridge at time
t is a time when

849
00:42:45,150 --> 00:42:47,160
everything that's
currently in the queue

850
00:42:47,160 --> 00:42:48,390
will finally be in the queue.

851
00:42:48,390 --> 00:42:51,880


852
00:42:51,880 --> 00:42:56,040
So this is a bridge.

853
00:42:56,040 --> 00:42:57,630
This is a bridge.

854
00:42:57,630 --> 00:43:01,050
Because these elements
exist for the rest of time.

855
00:43:01,050 --> 00:43:03,610
This is a bridge.

856
00:43:03,610 --> 00:43:05,370
OK, these are basically--

857
00:43:05,370 --> 00:43:07,230
interesting stuff
happens between bridges.

858
00:43:07,230 --> 00:43:11,430
Bridges are the points of rest
when things are kind of boring.

859
00:43:11,430 --> 00:43:15,691
We'll need this for
the next statement.

860
00:43:15,691 --> 00:43:18,867


861
00:43:18,867 --> 00:43:20,700
And the other claim is
it's easy to maintain

862
00:43:20,700 --> 00:43:21,616
where the bridges are.

863
00:43:21,616 --> 00:43:23,477
That's not a big surprise.

864
00:43:23,477 --> 00:43:25,560
Because there's no chain
reactions at the bridges.

865
00:43:25,560 --> 00:43:40,330


866
00:43:40,330 --> 00:43:42,400
So if I have a time
t that I care about--

867
00:43:42,400 --> 00:43:45,370
I want to compute this
formula for time t--

868
00:43:45,370 --> 00:43:47,770
what I do is find
the preceding bridge.

869
00:43:47,770 --> 00:43:49,610
Call it t prime.

870
00:43:49,610 --> 00:43:53,002
This is like-- an
arbitrary time t like here,

871
00:43:53,002 --> 00:43:54,460
we're in the middle
of some action.

872
00:43:54,460 --> 00:43:55,918
I want to know what
that action is.

873
00:43:55,918 --> 00:43:58,850
So I want to go to the
preceding blue line.

874
00:43:58,850 --> 00:44:00,680
So that's t prime.

875
00:44:00,680 --> 00:44:04,750
If my query is here,
t prime will be there.

876
00:44:04,750 --> 00:44:07,550


877
00:44:07,550 --> 00:44:14,800
Then, what I want to know is
this max of k prime where k

878
00:44:14,800 --> 00:44:23,157
prime is deleted after time t.

879
00:44:23,157 --> 00:44:27,450


880
00:44:27,450 --> 00:44:30,564
I should say greater equal
to t, instead of after,

881
00:44:30,564 --> 00:44:31,480
a little more precise.

882
00:44:31,480 --> 00:44:35,230


883
00:44:35,230 --> 00:44:42,660
Claim this equals the
max over all k prime

884
00:44:42,660 --> 00:44:45,760
not in the final queue,
because those guys obviously

885
00:44:45,760 --> 00:44:46,270
still exist.

886
00:44:46,270 --> 00:44:50,050


887
00:44:50,050 --> 00:44:59,930
Where k prime is inserted
at time greater than

888
00:44:59,930 --> 00:45:02,940
or equal to t prime.

889
00:45:02,940 --> 00:45:05,930
So basically I can turn the word
deleted into the word inserted,

890
00:45:05,930 --> 00:45:07,930
if I change t to t prime.

891
00:45:07,930 --> 00:45:10,770
And I also have to exclude
the guys at the top.

892
00:45:10,770 --> 00:45:14,247
So we're looking at a
particular time like here.

893
00:45:14,247 --> 00:45:15,830
I want to know who
are the things that

894
00:45:15,830 --> 00:45:16,880
are deleted after that.

895
00:45:16,880 --> 00:45:17,844
Well, this is deleted.

896
00:45:17,844 --> 00:45:18,510
This is deleted.

897
00:45:18,510 --> 00:45:21,170
All these guys
are deleted after.

898
00:45:21,170 --> 00:45:23,807
I'm going to rewind to t
prime and say, well, you

899
00:45:23,807 --> 00:45:25,640
know there are these
guys that they survive.

900
00:45:25,640 --> 00:45:27,015
They obviously
don't get deleted.

901
00:45:27,015 --> 00:45:31,100
But if you ignore the guys
that end up in the final queue,

902
00:45:31,100 --> 00:45:33,795
the guys that get
deleted after time t

903
00:45:33,795 --> 00:45:36,170
are the same as the ones that
get inserted after t prime.

904
00:45:36,170 --> 00:45:38,792


905
00:45:38,792 --> 00:45:39,500
That's the claim.

906
00:45:39,500 --> 00:45:42,230
Or actually, that set of
elements is not the same,

907
00:45:42,230 --> 00:45:43,910
but the max will be the same.

908
00:45:43,910 --> 00:45:45,384
That's all I care about.

909
00:45:45,384 --> 00:45:46,550
I only want to know the max.

910
00:45:46,550 --> 00:45:48,320
The max among all
the ones deleted here

911
00:45:48,320 --> 00:45:51,529
is this upper uppermost segment.

912
00:45:51,529 --> 00:45:53,570
And that's the same as
the max among all the guys

913
00:45:53,570 --> 00:45:54,960
that are inserted after here.

914
00:45:54,960 --> 00:45:57,560
So it's really just a
claim about this one being

915
00:45:57,560 --> 00:46:01,649
inserted after this bridge.

916
00:46:01,649 --> 00:46:02,690
I won't prove this Lemma.

917
00:46:02,690 --> 00:46:05,320
It's just, you think about
it for long enough, it

918
00:46:05,320 --> 00:46:06,770
becomes obvious.

919
00:46:06,770 --> 00:46:08,792
Leave it at that.

920
00:46:08,792 --> 00:46:10,250
Now we can do some
data structures,

921
00:46:10,250 --> 00:46:12,440
because now we have something
that we can reasonably

922
00:46:12,440 --> 00:46:13,148
hope to maintain.

923
00:46:13,148 --> 00:46:21,220


924
00:46:21,220 --> 00:46:23,470
So maintaining
bridges, one thing--

925
00:46:23,470 --> 00:46:27,170


926
00:46:27,170 --> 00:46:29,910
Yeah, actually kind
of an important thing.

927
00:46:29,910 --> 00:46:32,469


928
00:46:32,469 --> 00:46:34,010
So here's where
we're going to store.

929
00:46:34,010 --> 00:46:38,040
We're going to store the current
Q as a balanced binary search

930
00:46:38,040 --> 00:46:39,620
tree.

931
00:46:39,620 --> 00:46:43,056
OK, that's not very exciting.

932
00:46:43,056 --> 00:46:45,450
Though the hard part
is to figure out how

933
00:46:45,450 --> 00:46:47,630
Q now is changing at each step.

934
00:46:47,630 --> 00:46:49,890
But this will allow us
to do arbitrary queries

935
00:46:49,890 --> 00:46:53,280
on the final result

936
00:46:53,280 --> 00:47:02,760
We want to store a balanced
binary search tree whose leaves

937
00:47:02,760 --> 00:47:04,230
represent insertions.

938
00:47:04,230 --> 00:47:08,400


939
00:47:08,400 --> 00:47:10,455
So lowercase insertions.

940
00:47:10,455 --> 00:47:13,075
So that's all of the
rightward arrows.

941
00:47:13,075 --> 00:47:15,960


942
00:47:15,960 --> 00:47:18,600
And they're are going
to be sorted by time.

943
00:47:18,600 --> 00:47:23,270


944
00:47:23,270 --> 00:47:26,540
Not by a key value.

945
00:47:26,540 --> 00:47:29,160
OK, and I'm going to augment
that balanced binary search

946
00:47:29,160 --> 00:47:39,540
tree with a fun
value for every node

947
00:47:39,540 --> 00:47:41,190
in the balanced
binary search tree.

948
00:47:41,190 --> 00:47:44,820
I want to know max
of all the keys

949
00:47:44,820 --> 00:47:48,090
not currently in
the queue, or not

950
00:47:48,090 --> 00:47:50,582
presently in the queue
at the end of time.

951
00:47:50,582 --> 00:47:53,580
That changes is very slowly,
so this is easy to maintain.

952
00:47:53,580 --> 00:47:57,510


953
00:47:57,510 --> 00:47:59,340
Among all the keys
that are inserted

954
00:47:59,340 --> 00:48:04,210
in the subtree rooted at x.

955
00:48:04,210 --> 00:48:08,220
OK, that's basically this
value, which I want to maintain,

956
00:48:08,220 --> 00:48:10,350
but split up over a subtree.

957
00:48:10,350 --> 00:48:12,240
And so that lets me
easily compute this value

958
00:48:12,240 --> 00:48:18,470
by taking the max of log n
of these values at any time.

959
00:48:18,470 --> 00:48:23,310
OK, then we store another
balanced binary search tree

960
00:48:23,310 --> 00:48:25,410
where the leaves
are all the updates.

961
00:48:25,410 --> 00:48:31,610


962
00:48:31,610 --> 00:48:33,210
Again they will be
ordered by time.

963
00:48:33,210 --> 00:48:41,040


964
00:48:41,040 --> 00:48:42,792
And they will be augmented.

965
00:48:42,792 --> 00:48:50,360


966
00:48:50,360 --> 00:48:53,250
In each node, I'm going
to store a number which

967
00:48:53,250 --> 00:48:55,440
is 0 plus 1 or minus 1.

968
00:48:55,440 --> 00:48:58,950
It's going to be
0 for an insert.

969
00:48:58,950 --> 00:49:01,587


970
00:49:01,587 --> 00:49:03,420
This is at the leaf
level because the leaves

971
00:49:03,420 --> 00:49:06,480
correspond to updates.

972
00:49:06,480 --> 00:49:11,940
If that key ends up
in the final queue.

973
00:49:11,940 --> 00:49:14,020
So those we just ignore.

974
00:49:14,020 --> 00:49:18,630
It's going to be plus 1 for
any other kind of insert.

975
00:49:18,630 --> 00:49:21,300


976
00:49:21,300 --> 00:49:27,430
Inserting a key where
k is not in Q now.

977
00:49:27,430 --> 00:49:30,375
And it's going to be
minus 1 for a delete-min.

978
00:49:30,375 --> 00:49:35,810


979
00:49:35,810 --> 00:49:37,470
I'm going to store this.

980
00:49:37,470 --> 00:49:41,435
And we're going to
have subtree sums.

981
00:49:41,435 --> 00:49:45,330


982
00:49:45,330 --> 00:49:49,200
So this is fun
with augmentation.

983
00:49:49,200 --> 00:49:51,680
Why do I do all that?

984
00:49:51,680 --> 00:49:57,920
Because if I store
all these numbers,

985
00:49:57,920 --> 00:50:00,660
it becomes really easy
to detect bridges.

986
00:50:00,660 --> 00:50:04,442


987
00:50:04,442 --> 00:50:05,434
I claim.

988
00:50:05,434 --> 00:50:14,527


989
00:50:14,527 --> 00:50:15,360
AUDIENCE: Professor?

990
00:50:15,360 --> 00:50:16,151
ERIK DEMAINE: Yeah?

991
00:50:16,151 --> 00:50:19,099
AUDIENCE: So, what we're
looking for is basically

992
00:50:19,099 --> 00:50:23,874
we know how the cascade
went in any given--

993
00:50:23,874 --> 00:50:26,290
ERIK DEMAINE: We want to compute
how one of these cascades

994
00:50:26,290 --> 00:50:26,790
will end.

995
00:50:26,790 --> 00:50:29,325
AUDIENCE: And so we just always
maintain that information?

996
00:50:29,325 --> 00:50:31,700
ERIK DEMAINE: We're always
going to maintain what's here.

997
00:50:31,700 --> 00:50:33,820
We can't afford to
maintain this whole picture

998
00:50:33,820 --> 00:50:35,800
because it changes too much.

999
00:50:35,800 --> 00:50:36,960
But we want to--

1000
00:50:36,960 --> 00:50:37,720
we're given this.

1001
00:50:37,720 --> 00:50:39,520
We want to know the
result of the cascade,

1002
00:50:39,520 --> 00:50:42,000
without having to do all
that stuff in the middle.

1003
00:50:42,000 --> 00:50:43,530
Yeah, that's our goal.

1004
00:50:43,530 --> 00:50:46,040
And I claim-- this
is a lot of text.

1005
00:50:46,040 --> 00:50:47,800
But I claim that
this information

1006
00:50:47,800 --> 00:50:50,200
is enough to do
that in log n time.

1007
00:50:50,200 --> 00:50:52,620
So let me try to convince you.

1008
00:50:52,620 --> 00:50:55,470
AUDIENCE: So are you storing
several binary searches?

1009
00:50:55,470 --> 00:50:57,960
ERIK DEMAINE: I'm storing three.

1010
00:50:57,960 --> 00:51:00,370
I'm storing one that
represents the final result.

1011
00:51:00,370 --> 00:51:02,920
I'm storing one that's just
looking at the insertions.

1012
00:51:02,920 --> 00:51:05,360
I'm storing one that
looks at all the updates.

1013
00:51:05,360 --> 00:51:07,780
I maintain all three, and
you can cross-link them

1014
00:51:07,780 --> 00:51:10,700
all you want.

1015
00:51:10,700 --> 00:51:18,910
OK, I claim a bridge
is now a prefix

1016
00:51:18,910 --> 00:51:30,250
of updates summing to zero,
according to this measure.

1017
00:51:30,250 --> 00:51:33,730
Because inserts and deletes,
when they all cancel out--

1018
00:51:33,730 --> 00:51:37,990
and if we ignore the things
that finally end up there,

1019
00:51:37,990 --> 00:51:41,200
the periods of rest,
when no one is active

1020
00:51:41,200 --> 00:51:42,820
that will eventually
get deleted,

1021
00:51:42,820 --> 00:51:46,420
that's exactly when everyone
to the left has been deleted

1022
00:51:46,420 --> 00:51:48,080
or will survive to the end.

1023
00:51:48,080 --> 00:51:52,540
So these guys counts as
zeros, so we ignore those.

1024
00:51:52,540 --> 00:51:54,040
Each of these
corresponds to plus 1.

1025
00:51:54,040 --> 00:51:55,980
Each of these
corresponds to a minus 1.

1026
00:51:55,980 --> 00:51:58,460
So these have all
canceled out by now.

1027
00:51:58,460 --> 00:52:00,670
And when this prefix
sum, which is everything

1028
00:52:00,670 --> 00:52:05,170
up to a given point, is
zero, then that is a bridge.

1029
00:52:05,170 --> 00:52:09,700
What this lets you do
is if you have some--

1030
00:52:09,700 --> 00:52:12,070
you have this
binary search tree.

1031
00:52:12,070 --> 00:52:15,160
You have some query time t,
which corresponds to a leaf.

1032
00:52:15,160 --> 00:52:18,490
And now I want to know what
is the preceding bridge?

1033
00:52:18,490 --> 00:52:22,150
I want to know t prime, the
bridge proceeding time t.

1034
00:52:22,150 --> 00:52:24,820
Then basically I
walk up this tree

1035
00:52:24,820 --> 00:52:26,700
and find the preceding moments--

1036
00:52:26,700 --> 00:52:30,520
I actually have to first walk
down to compute all the sums.

1037
00:52:30,520 --> 00:52:33,520
So hanging off on
the left of this path

1038
00:52:33,520 --> 00:52:36,895
are all these times in the past.

1039
00:52:36,895 --> 00:52:42,165
And I say well, if the sum of
all of those subtree sums, sum

1040
00:52:42,165 --> 00:52:44,290
of all the values in those
leaves, if that's 0 then

1041
00:52:44,290 --> 00:52:46,990
we're already at a bridge.

1042
00:52:46,990 --> 00:52:49,990
If not, I basically compute
the preceding point where

1043
00:52:49,990 --> 00:52:52,820
this sum up to that point is 0.

1044
00:52:52,820 --> 00:52:54,940
And that should be
relatively obvious how to do.

1045
00:52:54,940 --> 00:52:58,300
It's a regular kind of
walking up the tree.

1046
00:52:58,300 --> 00:53:02,580
So log n time I can find
the preceding bridge.

1047
00:53:02,580 --> 00:53:07,450


1048
00:53:07,450 --> 00:53:09,790
Because I have all
these subtrees sums

1049
00:53:09,790 --> 00:53:19,300
I can do that by a tree walk.

1050
00:53:19,300 --> 00:53:24,370
OK, then it just says
here, "And then you

1051
00:53:24,370 --> 00:53:26,440
can compute the change to Qnow."

1052
00:53:26,440 --> 00:53:29,410
How do we compute
the change to Qnow?

1053
00:53:29,410 --> 00:53:32,950
We have to compute this
max of all the keys

1054
00:53:32,950 --> 00:53:36,230
that are inserted
after time t prime.

1055
00:53:36,230 --> 00:53:38,515
So this was the
tree of all updates.

1056
00:53:38,515 --> 00:53:41,290


1057
00:53:41,290 --> 00:53:46,780
And we have another tree, which
is just the tree of insertions.

1058
00:53:46,780 --> 00:53:48,880
And so if we
cross-link time-- so

1059
00:53:48,880 --> 00:53:53,200
we find t prime, where
the prefix sum is zero.

1060
00:53:53,200 --> 00:53:56,260
We map over to t prime here.

1061
00:53:56,260 --> 00:53:58,210
And again we get a
root to leaf path.

1062
00:53:58,210 --> 00:54:00,490
And now we look at all of
the elements hanging off

1063
00:54:00,490 --> 00:54:03,082
the right side.

1064
00:54:03,082 --> 00:54:04,540
Those are all the
elements that are

1065
00:54:04,540 --> 00:54:06,430
inserted after time t prime.

1066
00:54:06,430 --> 00:54:07,870
And I just take
the max of those.

1067
00:54:07,870 --> 00:54:09,328
So I guess I didn't
write it, but I

1068
00:54:09,328 --> 00:54:10,760
need to store our subtree--

1069
00:54:10,760 --> 00:54:12,190
oh no, I store this.

1070
00:54:12,190 --> 00:54:13,615
Right, this is what I want.

1071
00:54:13,615 --> 00:54:14,990
For every subtree,
I want to know

1072
00:54:14,990 --> 00:54:16,573
the max of the things
in that subtree,

1073
00:54:16,573 --> 00:54:20,680
but ignoring the guys
that are in Qnow.

1074
00:54:20,680 --> 00:54:25,550
I take all those maxes
on all those subtrees.

1075
00:54:25,550 --> 00:54:36,190
And I can find what element
gets inserted into Qnow in log n

1076
00:54:36,190 --> 00:54:37,159
time.

1077
00:54:37,159 --> 00:54:39,450
Then, of course, I have to
update all this information.

1078
00:54:39,450 --> 00:54:41,140
And I don't want
to spend any more

1079
00:54:41,140 --> 00:54:44,170
time on this, no pun intended.

1080
00:54:44,170 --> 00:54:46,750
You have to-- then Qnow changes.

1081
00:54:46,750 --> 00:54:50,560
And so you've got to update all
these values and these values.

1082
00:54:50,560 --> 00:54:53,830
But the claim is that you can
do all that in log n time.

1083
00:54:53,830 --> 00:54:56,730
It's not hard.

1084
00:54:56,730 --> 00:54:58,380
OK, that's priority queues.

1085
00:54:58,380 --> 00:55:00,450
So I know that was a
little bit tedious.

1086
00:55:00,450 --> 00:55:02,626
But this is sort of--

1087
00:55:02,626 --> 00:55:04,750
it's not quite the coolest
thing we know how to do,

1088
00:55:04,750 --> 00:55:06,800
but it was the first
cool thing we knew how

1089
00:55:06,800 --> 00:55:08,190
to do in the retroactive world.

1090
00:55:08,190 --> 00:55:11,400
It's this nice borderline
where it looks scary.

1091
00:55:11,400 --> 00:55:13,680
There are linear-sized
chain reactions.

1092
00:55:13,680 --> 00:55:18,840
Yet we can still deal
with them in log n time.

1093
00:55:18,840 --> 00:55:24,000
So not quite the worst
case, but also not easy.

1094
00:55:24,000 --> 00:55:26,490
So in general, if you want
a retroactive data structure

1095
00:55:26,490 --> 00:55:29,880
for your favorite
data structure,

1096
00:55:29,880 --> 00:55:32,130
you're going to have to
think along these lines,

1097
00:55:32,130 --> 00:55:36,600
see whether you can maintain
something reasonable.

1098
00:55:36,600 --> 00:55:42,030
Let me tell you briefly about
other problems, other data

1099
00:55:42,030 --> 00:55:44,350
structures that we've looked
at, and other people have

1100
00:55:44,350 --> 00:55:44,850
looked at.

1101
00:55:44,850 --> 00:55:50,140


1102
00:55:50,140 --> 00:55:55,830
So a simple one is a queue,
first in, first out first in,

1103
00:55:55,830 --> 00:55:56,690
last out.

1104
00:55:56,690 --> 00:55:58,020
One of those.

1105
00:55:58,020 --> 00:56:00,390
I've got stacks too, probably.

1106
00:56:00,390 --> 00:56:03,780
You can do constant time
partial retroactivity.

1107
00:56:03,780 --> 00:56:09,584
Log n time full
retroactivity for a deque.

1108
00:56:09,584 --> 00:56:12,000
I mentioned this last time
where you can insert and delete

1109
00:56:12,000 --> 00:56:13,680
from either end.

1110
00:56:13,680 --> 00:56:21,220
We can do log n full
retroactivity for union-find.

1111
00:56:21,220 --> 00:56:24,360


1112
00:56:24,360 --> 00:56:25,440
You have a bunch of sets.

1113
00:56:25,440 --> 00:56:26,790
You want to be able
to take their union.

1114
00:56:26,790 --> 00:56:29,380
And given an element you want
to know which set it's in.

1115
00:56:29,380 --> 00:56:32,980
It's sometimes taught in 6046.

1116
00:56:32,980 --> 00:56:38,316
The best thing we know is
log m fully retroactive.

1117
00:56:38,316 --> 00:56:41,970


1118
00:56:41,970 --> 00:56:43,851
Priority queue we
already talked about.

1119
00:56:43,851 --> 00:56:44,350
But--

1120
00:56:44,350 --> 00:56:46,150
AUDIENCE: [INAUDIBLE]

1121
00:56:46,150 --> 00:56:49,565
ERIK DEMAINE: Is
there a question?

1122
00:56:49,565 --> 00:56:51,854
Priority queue, we already
did partial retroactivity.

1123
00:56:51,854 --> 00:56:53,520
But what if you want
full retroactivity?

1124
00:56:53,520 --> 00:56:55,550
This is pretty much
an open problem.

1125
00:56:55,550 --> 00:56:59,700
Best thing we know is square
root of m to m's log n.

1126
00:56:59,700 --> 00:57:01,639
This is via-- we have
a general result that

1127
00:57:01,639 --> 00:57:03,930
says if you have anything
that's partially retroactive,

1128
00:57:03,930 --> 00:57:05,580
you can make it
fully retroactive

1129
00:57:05,580 --> 00:57:09,180
at a huge cost of
square root of m factor.

1130
00:57:09,180 --> 00:57:12,560
So you could take what we have,
make it fully retroactive.

1131
00:57:12,560 --> 00:57:13,780
Full.

1132
00:57:13,780 --> 00:57:16,365
AUDIENCE: Is there any
difference when you're

1133
00:57:16,365 --> 00:57:19,387
talking about n [INAUDIBLE]

1134
00:57:19,387 --> 00:57:20,970
ERIK DEMAINE: n, I
think it's supposed

1135
00:57:20,970 --> 00:57:25,339
to be the current size
of the data structure.

1136
00:57:25,339 --> 00:57:26,880
I'm not actually
sure what that means

1137
00:57:26,880 --> 00:57:28,110
with a retroactive operation.

1138
00:57:28,110 --> 00:57:30,510
I'll just make them all m's.

1139
00:57:30,510 --> 00:57:33,250
I think that's safer.

1140
00:57:33,250 --> 00:57:34,730
Other question or same one?

1141
00:57:34,730 --> 00:57:38,780
OK good, thank you.

1142
00:57:38,780 --> 00:57:41,237
OK, let me tell you about
the most important problem

1143
00:57:41,237 --> 00:57:41,820
in this field.

1144
00:57:41,820 --> 00:57:44,730


1145
00:57:44,730 --> 00:57:46,440
This is actually
what motivated us

1146
00:57:46,440 --> 00:57:50,310
to define retroactivity,
which is a particular problem,

1147
00:57:50,310 --> 00:57:51,750
retroactive successor.

1148
00:57:51,750 --> 00:57:56,040
So successor problem is I want
to be able to insert and delete

1149
00:57:56,040 --> 00:57:58,500
keys in one dimension.

1150
00:57:58,500 --> 00:58:00,690
And given a query
key, I want to know

1151
00:58:00,690 --> 00:58:02,640
what is the next key
greater or equal to it.

1152
00:58:02,640 --> 00:58:04,181
This is something
you can do in log n

1153
00:58:04,181 --> 00:58:06,580
time with a balanced
binary search tree.

1154
00:58:06,580 --> 00:58:08,080
There's lots of
other ways to do it,

1155
00:58:08,080 --> 00:58:10,050
which we will get to
later in this class.

1156
00:58:10,050 --> 00:58:13,170
But what if I want to
do it fully retroactive?

1157
00:58:13,170 --> 00:58:15,420
Partially retroactive
is really easy,

1158
00:58:15,420 --> 00:58:20,100
because this is
a search problem.

1159
00:58:20,100 --> 00:58:25,550
So I can definitely do log
m partial retroactivity.

1160
00:58:25,550 --> 00:58:28,540


1161
00:58:28,540 --> 00:58:30,235
In fact, it is a--

1162
00:58:30,235 --> 00:58:33,900
I just use a regular binary
search tree, or whatever.

1163
00:58:33,900 --> 00:58:37,350
In fact, it is a
decomposable search problem.

1164
00:58:37,350 --> 00:58:39,920
So I get full
retroactivity, no problem.

1165
00:58:39,920 --> 00:58:41,760
But I pay a log
factor, so I get log

1166
00:58:41,760 --> 00:58:45,870
squared m, full retroactivity.

1167
00:58:45,870 --> 00:58:50,640
And so that's where we
left it, back in 2003.

1168
00:58:50,640 --> 00:58:52,290
But there's a new
result, which is

1169
00:58:52,290 --> 00:58:56,170
that you can actually get
log m without the square full

1170
00:58:56,170 --> 00:58:58,680
retroactivity.

1171
00:58:58,680 --> 00:59:03,370
This is a complicated result.
It's by Goran and Kaplan, 2009.

1172
00:59:03,370 --> 00:59:06,060
It uses fun techniques like
fractional cascading, which

1173
00:59:06,060 --> 00:59:11,400
is next lecture, and van Emde
Boas, which is lecture 11,

1174
00:59:11,400 --> 00:59:14,560
and various other tools.

1175
00:59:14,560 --> 00:59:17,790
So it's a little too
advanced to cover now.

1176
00:59:17,790 --> 00:59:19,500
But it's cool.

1177
00:59:19,500 --> 00:59:21,960
And it has lots of applications
in geometry, which we will

1178
00:59:21,960 --> 00:59:23,580
be talking about next class.

1179
00:59:23,580 --> 00:59:27,790
So hold your breath
for that, I guess.

1180
00:59:27,790 --> 00:59:28,980
Yeah.

1181
00:59:28,980 --> 00:59:32,640
I want to go to one
last topic, which

1182
00:59:32,640 --> 01:00:28,330
is a different kind
of retro activity

1183
01:00:28,330 --> 01:00:32,300
Nonoblivious retroactivity is
introduced by Acar, Blelloch,

1184
01:00:32,300 --> 01:00:36,320
Tangwongsan in 2007.

1185
01:00:36,320 --> 01:00:38,900
And it's basically
answering the question

1186
01:00:38,900 --> 01:00:40,610
"What about my queries?"

1187
01:00:40,610 --> 01:00:44,720
So we have this
timeline of updates.

1188
01:00:44,720 --> 01:00:47,810
And we've done
various operations

1189
01:00:47,810 --> 01:00:51,924
on our data structure,
which are the updates.

1190
01:00:51,924 --> 01:00:53,840
And we've considered how
those can be changed.

1191
01:00:53,840 --> 01:00:56,150
And then with queries, either
we're querying at the end

1192
01:00:56,150 --> 01:00:57,282
or querying in the middle.

1193
01:00:57,282 --> 01:00:59,240
But we're always getting
sort of instantaneous,

1194
01:00:59,240 --> 01:01:03,200
as the timeline exists
right now, here's what

1195
01:01:03,200 --> 01:01:05,120
the result of your query is.

1196
01:01:05,120 --> 01:01:07,190
But what if I want to do--

1197
01:01:07,190 --> 01:01:10,370
I mean, if I really-- normally
when I use a data structure,

1198
01:01:10,370 --> 01:01:11,630
I do some updates.

1199
01:01:11,630 --> 01:01:13,550
I do some queries.

1200
01:01:13,550 --> 01:01:17,030
I do a combination
of these things.

1201
01:01:17,030 --> 01:01:21,320
And to make life worse,
when I do a query,

1202
01:01:21,320 --> 01:01:23,090
the result of that
query probably

1203
01:01:23,090 --> 01:01:25,530
influences what updates
I do in the future.

1204
01:01:25,530 --> 01:01:28,060
So real use, I'll just
call that the algorithmic

1205
01:01:28,060 --> 01:01:29,543
use of a data structure.

1206
01:01:29,543 --> 01:01:36,800


1207
01:01:36,800 --> 01:01:41,622
Results of queries
influence updates,

1208
01:01:41,622 --> 01:01:42,830
what updates are going to do.

1209
01:01:42,830 --> 01:01:47,370


1210
01:01:47,370 --> 01:01:52,557
OK, and now this gets a
little dicey, because what

1211
01:01:52,557 --> 01:01:53,390
does influence mean?

1212
01:01:53,390 --> 01:01:56,360
We don't know, because
that's the user somehow

1213
01:01:56,360 --> 01:01:59,310
depends on these results.

1214
01:01:59,310 --> 01:02:02,780
So nonoblivious retroactivity is
trying to deal with this issue.

1215
01:02:02,780 --> 01:02:05,190
Can we get something reasonable?

1216
01:02:05,190 --> 01:02:07,370
So what we'd like to
do is say, oh I now

1217
01:02:07,370 --> 01:02:10,220
add an update over
here, retroactively.

1218
01:02:10,220 --> 01:02:13,300
So their updates are
the same, in some sense.

1219
01:02:13,300 --> 01:02:18,260
You can retroactively insert and
delete updates and queries now.

1220
01:02:18,260 --> 01:02:21,980
I'd like to know well, did the
result of this query change?

1221
01:02:21,980 --> 01:02:23,150
Maybe you can show--

1222
01:02:23,150 --> 01:02:24,920
at the data structure
level we can tell

1223
01:02:24,920 --> 01:02:27,260
did that query result change.

1224
01:02:27,260 --> 01:02:30,980
Maybe this one changed,
but this one did not.

1225
01:02:30,980 --> 01:02:32,510
What we'd like to
report to the user

1226
01:02:32,510 --> 01:02:36,080
is what is the first
query that changed,

1227
01:02:36,080 --> 01:02:38,790
because that's like the
first mistake that you made.

1228
01:02:38,790 --> 01:02:40,640
Like oh you know,
retroactively oops

1229
01:02:40,640 --> 01:02:43,610
I should have deposited
$100 back here.

1230
01:02:43,610 --> 01:02:45,620
And then these
queries which we're

1231
01:02:45,620 --> 01:02:48,200
checking whether the balance
was positive or negative,

1232
01:02:48,200 --> 01:02:52,130
some of their results might
change, some of them might not.

1233
01:02:52,130 --> 01:02:54,500
If they change, then
the algorithm has to--

1234
01:02:54,500 --> 01:02:56,600
I mean, it doesn't have
to rerun these operations,

1235
01:02:56,600 --> 01:02:59,000
because that's what
retroactivity buys for you.

1236
01:02:59,000 --> 01:03:02,120
But it has to say, oh well,
now this query has changed.

1237
01:03:02,120 --> 01:03:05,580
And then you have to rerun
the algorithm from that point.

1238
01:03:05,580 --> 01:03:07,940
But not necessarily entirely.

1239
01:03:07,940 --> 01:03:10,714
I mean, you look at
that and say, oh,

1240
01:03:10,714 --> 01:03:12,380
did that query actually
change anything?

1241
01:03:12,380 --> 01:03:14,120
This is now the algorithm.

1242
01:03:14,120 --> 01:03:17,840
Oh yeah, instead of this
update here, I would have made

1243
01:03:17,840 --> 01:03:20,060
a different update u prime.

1244
01:03:20,060 --> 01:03:21,810
Well, that's good, we
know how to do that.

1245
01:03:21,810 --> 01:03:23,610
That's a retroactive update.

1246
01:03:23,610 --> 01:03:25,970
So I can delete this
operation retroactively

1247
01:03:25,970 --> 01:03:27,775
and insert this one.

1248
01:03:27,775 --> 01:03:29,900
So in general, what we
assume the algorithm does is

1249
01:03:29,900 --> 01:03:32,810
it looks at the
first error, which is

1250
01:03:32,810 --> 01:03:35,130
reported by our data structure.

1251
01:03:35,130 --> 01:03:38,690
And then it then may
make various changes

1252
01:03:38,690 --> 01:03:41,266
from that point onward,
but always monotonically

1253
01:03:41,266 --> 01:03:42,640
left to right, as
if it was rerun

1254
01:03:42,640 --> 01:03:47,670
in the algorithm, but just
changing what needed to change,

1255
01:03:47,670 --> 01:03:49,860
until all the
errors are resolved.

1256
01:03:49,860 --> 01:03:52,920
All the queries have been
corrected to the right answers.

1257
01:03:52,920 --> 01:03:54,450
Then it can do
whatever it wants.

1258
01:03:54,450 --> 01:03:57,860
Then it can do retroactive
operation anytime in the past.

1259
01:03:57,860 --> 01:04:01,050
OK, so this is an assumption.

1260
01:04:01,050 --> 01:04:15,150
Assume once there's an error,
that the algorithm makes

1261
01:04:15,150 --> 01:04:26,220
changes, retroactive
updates, from left to right.

1262
01:04:26,220 --> 01:04:31,260


1263
01:04:31,260 --> 01:04:41,460
And also going to assume that
it does it at times less than

1264
01:04:41,460 --> 01:04:42,555
or equal to all errors.

1265
01:04:42,555 --> 01:04:46,980


1266
01:04:46,980 --> 01:04:50,920
So in general, you
have a timeline.

1267
01:04:50,920 --> 01:04:56,280
And then there are some errors
where bad queries were done.

1268
01:04:56,280 --> 01:04:57,919
Naturally, you
would go right here

1269
01:04:57,919 --> 01:04:59,460
and fix the first
error, because that

1270
01:04:59,460 --> 01:05:01,540
may influence other errors.

1271
01:05:01,540 --> 01:05:03,260
And maybe you have--

1272
01:05:03,260 --> 01:05:04,770
so then you make that change.

1273
01:05:04,770 --> 01:05:06,600
Maybe then that causes
some other changes

1274
01:05:06,600 --> 01:05:09,370
right after or
somewhere in between.

1275
01:05:09,370 --> 01:05:12,270
But then I don't want
to make a change here,

1276
01:05:12,270 --> 01:05:14,610
because that would be
depending on this result, which

1277
01:05:14,610 --> 01:05:15,290
was incorrect.

1278
01:05:15,290 --> 01:05:17,280
So first you have to fix this.

1279
01:05:17,280 --> 01:05:20,550
So you keep going to the right
and you visit all the stars.

1280
01:05:20,550 --> 01:05:23,962
That's this assumption.

1281
01:05:23,962 --> 01:05:26,800


1282
01:05:26,800 --> 01:05:28,920
This is a very different
kind of retroactivity.

1283
01:05:28,920 --> 01:05:34,140
I would say it's more about
maintaining this exact picture

1284
01:05:34,140 --> 01:05:38,160
of what's happening, but
being able to teleport over

1285
01:05:38,160 --> 01:05:40,320
the uninteresting stuff.

1286
01:05:40,320 --> 01:05:43,950
So in this picture, if
we're doing priority queues

1287
01:05:43,950 --> 01:05:45,990
like this, when I
make this change,

1288
01:05:45,990 --> 01:05:47,130
well, that query changes.

1289
01:05:47,130 --> 01:05:48,310
That query changes.

1290
01:05:48,310 --> 01:05:52,740
The delete-mins, the mins
that they're deleting change.

1291
01:05:52,740 --> 01:05:54,150
So here they were just updates.

1292
01:05:54,150 --> 01:05:57,057
But if there's also a query
here, which is what is the min,

1293
01:05:57,057 --> 01:05:58,890
then all of these query
values would change.

1294
01:05:58,890 --> 01:06:02,420


1295
01:06:02,420 --> 01:06:05,390
So you're forced
now to pay for that.

1296
01:06:05,390 --> 01:06:07,520
So in some sense,
it gets easier.

1297
01:06:07,520 --> 01:06:08,290
Let's say.

1298
01:06:08,290 --> 01:06:11,210
For a lot of problems this kind
of retroactivity is easier.

1299
01:06:11,210 --> 01:06:13,220
But for many problems,
it's also more useful.

1300
01:06:13,220 --> 01:06:16,640
So their example is what if you
want to do a dynamic Dijkstra?

1301
01:06:16,640 --> 01:06:18,130
So you have
Dijkstra's algorithm,

1302
01:06:18,130 --> 01:06:21,120
and then you say, oh, actually
this edge weight was wrong.

1303
01:06:21,120 --> 01:06:22,941
So you run Dijkstra's
algorithm once.

1304
01:06:22,941 --> 01:06:24,940
You've got a priority
queue in there telling you

1305
01:06:24,940 --> 01:06:26,740
which vertex is next.

1306
01:06:26,740 --> 01:06:29,251


1307
01:06:29,251 --> 01:06:31,000
And now you say, OK,
I changed this weight

1308
01:06:31,000 --> 01:06:32,680
at the beginning of time.

1309
01:06:32,680 --> 01:06:34,690
I don't want to have to
rerun Dijkstra entirely

1310
01:06:34,690 --> 01:06:36,040
if nothing changes.

1311
01:06:36,040 --> 01:06:38,240
Maybe that weight was
completely irrelevant.

1312
01:06:38,240 --> 01:06:40,422
If you just do a
retroactive update and see

1313
01:06:40,422 --> 01:06:42,880
did any of the query results
change, if they didn't change,

1314
01:06:42,880 --> 01:06:44,421
then great you have
the right answer.

1315
01:06:44,421 --> 01:06:46,090
If they did change,
the results change.

1316
01:06:46,090 --> 01:06:48,970
And so you have to know
for every wrong query

1317
01:06:48,970 --> 01:06:51,520
that oh, I really had to
change the shortest pathway.

1318
01:06:51,520 --> 01:06:53,440
It's not this, it's now this.

1319
01:06:53,440 --> 01:06:55,099
But hopefully,
you will only have

1320
01:06:55,099 --> 01:06:56,890
to change a very small
amount if your graph

1321
01:06:56,890 --> 01:06:58,900
didn't change in a big way.

1322
01:06:58,900 --> 01:07:02,680
So it's hard to proof results
about that, but at least

1323
01:07:02,680 --> 01:07:05,050
this would let you dynamize
almost any algorithm that's

1324
01:07:05,050 --> 01:07:06,220
using the data structure.

1325
01:07:06,220 --> 01:07:10,960
So it's easier, but useful for
that kind of transformation.

1326
01:07:10,960 --> 01:07:16,420
OK, let me give you an example,
which is priority queues.

1327
01:07:16,420 --> 01:07:20,679
There's a bunch of results in
their paper, but for symmetry.

1328
01:07:20,679 --> 01:07:21,970
Tell you about priority queues.

1329
01:07:21,970 --> 01:07:24,440
This will look completely
different, so don't worry.

1330
01:07:24,440 --> 01:07:27,150


1331
01:07:27,150 --> 01:07:30,470
Operations-- well, the
visual picture is the same,

1332
01:07:30,470 --> 01:07:33,950
but the data structuring is
all completely different.

1333
01:07:33,950 --> 01:07:36,990
They can do all
these things in log m

1334
01:07:36,990 --> 01:07:41,050
per retroactive operation.

1335
01:07:41,050 --> 01:07:43,780
Now there's no notion
of full and partial.

1336
01:07:43,780 --> 01:07:46,420
It's just nonoblivious
retroactivity.

1337
01:07:46,420 --> 01:07:48,820
I didn't write it here, but
the data structure always

1338
01:07:48,820 --> 01:07:52,255
maintains what is the
earliest error currently.

1339
01:07:52,255 --> 01:07:55,510


1340
01:07:55,510 --> 01:08:02,570
Maintain the earliest
in time error.

1341
01:08:02,570 --> 01:08:05,410
That error is a query that
used to return one result,

1342
01:08:05,410 --> 01:08:09,180
now returns a new result.

1343
01:08:09,180 --> 01:08:16,910
OK we have a similar picture.

1344
01:08:16,910 --> 01:08:19,185
So I cheated-- I've changed
things a little bit.

1345
01:08:19,185 --> 01:08:19,810
I didn't cheat.

1346
01:08:19,810 --> 01:08:22,670
It's just a slight discrepancy.

1347
01:08:22,670 --> 01:08:25,675
For retroactive, regular
retroactive, insert and

1348
01:08:25,675 --> 01:08:27,050
delete-min were
more interesting,

1349
01:08:27,050 --> 01:08:28,675
because then they
were chain reactions.

1350
01:08:28,675 --> 01:08:31,279
In this world you don't have
to combine delete and min.

1351
01:08:31,279 --> 01:08:33,890
You could consider
delete separate from min.

1352
01:08:33,890 --> 01:08:36,632
Because now, updates are
allowed to depend on queries.

1353
01:08:36,632 --> 01:08:38,090
So maybe you compute
a min and then

1354
01:08:38,090 --> 01:08:40,010
you decide to delete that thing.

1355
01:08:40,010 --> 01:08:42,439
If the min changes, well then,
the thing that got deleted

1356
01:08:42,439 --> 01:08:43,229
might also change.

1357
01:08:43,229 --> 01:08:45,560
That's the algorithm's choice.

1358
01:08:45,560 --> 01:08:47,580
What to do.

1359
01:08:47,580 --> 01:08:50,689
So in this new world of insert,
delete, and min, slightly more

1360
01:08:50,689 --> 01:08:56,050
general, if you look at an item,
it gets inserted at some time.

1361
01:08:56,050 --> 01:08:57,492
It might get deleted
at some time.

1362
01:08:57,492 --> 01:08:59,075
Sometimes it might
go off to infinity,

1363
01:08:59,075 --> 01:09:01,729
if it never gets deleted.

1364
01:09:01,729 --> 01:09:07,290
OK, this is our new picture of
the priority queue over time.

1365
01:09:07,290 --> 01:09:10,100
So again, this is the time axis.

1366
01:09:10,100 --> 01:09:12,760
And this is the key value.

1367
01:09:12,760 --> 01:09:14,310
So have some inserts, deletes.

1368
01:09:14,310 --> 01:09:16,460
They're all corresponding
points in here.

1369
01:09:16,460 --> 01:09:19,700
And then you have min queries,
which maybe I will draw in red.

1370
01:09:19,700 --> 01:09:22,649


1371
01:09:22,649 --> 01:09:26,550
So min query would be
something like this.

1372
01:09:26,550 --> 01:09:28,920
Give me what is the lowest
segment at this time.

1373
01:09:28,920 --> 01:09:34,100


1374
01:09:34,100 --> 01:09:35,580
So that's my sequence
of operations

1375
01:09:35,580 --> 01:09:37,706
is the projection onto
time, so there's this thing.

1376
01:09:37,706 --> 01:09:38,705
Then there's this query.

1377
01:09:38,705 --> 01:09:39,965
Then there's this insertion.

1378
01:09:39,965 --> 01:09:41,090
Then there's this deletion.

1379
01:09:41,090 --> 01:09:42,215
Then there's this deletion.

1380
01:09:42,215 --> 01:09:43,215
Then there's this query.

1381
01:09:43,215 --> 01:09:44,839
Min query, then
there's this insertion.

1382
01:09:44,839 --> 01:09:45,910
Then there's this query.

1383
01:09:45,910 --> 01:09:47,034
Then there's this deletion.

1384
01:09:47,034 --> 01:09:49,479
You get the idea.

1385
01:09:49,479 --> 01:09:51,240
But this is a way to
two-dimensionalize

1386
01:09:51,240 --> 01:09:53,259
that picture.

1387
01:09:53,259 --> 01:09:55,050
AUDIENCE: Can you delete
without the query?

1388
01:09:55,050 --> 01:09:56,158
ERIK DEMAINE: Sorry?

1389
01:09:56,158 --> 01:09:58,600
AUDIENCE: Can you delete
without the query?

1390
01:09:58,600 --> 01:10:02,484
ERIK DEMAINE: You can delete
without a query in this model.

1391
01:10:02,484 --> 01:10:03,900
Make our life a
little bit harder.

1392
01:10:03,900 --> 01:10:07,690
Now what we need to support
are capital insert, and capital

1393
01:10:07,690 --> 01:10:10,780
delete, retroactive insert
and delete, of all three

1394
01:10:10,780 --> 01:10:11,646
of these operations.

1395
01:10:11,646 --> 01:10:12,770
Before it was just updates.

1396
01:10:12,770 --> 01:10:15,660
Now we can insert
and delete queries.

1397
01:10:15,660 --> 01:10:17,180
A little harder to think about.

1398
01:10:17,180 --> 01:10:20,270
But it can be done.

1399
01:10:20,270 --> 01:10:22,264
So for example, let's just--

1400
01:10:22,264 --> 01:10:23,680
I'm not going to
do all the cases,

1401
01:10:23,680 --> 01:10:25,670
because there's a lot of them.

1402
01:10:25,670 --> 01:10:30,580
Let's say I delete
this deletion.

1403
01:10:30,580 --> 01:10:33,310
OK, that means that this
will just go to the right.

1404
01:10:33,310 --> 01:10:37,550


1405
01:10:37,550 --> 01:10:41,620
OK, that's bad, because it
changes all of these queries.

1406
01:10:41,620 --> 01:10:43,750
All of these queries
are now incorrect.

1407
01:10:43,750 --> 01:10:46,090
We're just going to keep
the picture like this

1408
01:10:46,090 --> 01:10:47,787
and remember that
there are errors.

1409
01:10:47,787 --> 01:10:49,870
And we'll be able to
maintain at every moment what

1410
01:10:49,870 --> 01:10:51,760
is the next error.

1411
01:10:51,760 --> 01:10:55,000
The errors are these crossings.

1412
01:10:55,000 --> 01:10:55,750
Crossings are bad.

1413
01:10:55,750 --> 01:10:58,270
That means you have
the wrong picture.

1414
01:10:58,270 --> 01:10:59,820
But we'll wait for
the algorithm--

1415
01:10:59,820 --> 01:11:01,690
we'll tell the algorithm
this is the next crossing.

1416
01:11:01,690 --> 01:11:04,148
And it's going to have to fix
it by say deleting that query

1417
01:11:04,148 --> 01:11:05,230
and then reinserting it.

1418
01:11:05,230 --> 01:11:06,760
Then it will get
the correct result.

1419
01:11:06,760 --> 01:11:08,620
But it might do other
updates meanwhile.

1420
01:11:08,620 --> 01:11:12,100
So let's not try to fix them
all now because they may change.

1421
01:11:12,100 --> 01:11:14,950
Maybe they'll decide to
re-insert a deletion here

1422
01:11:14,950 --> 01:11:17,565
to do that, and then erase
all of those crossings,

1423
01:11:17,565 --> 01:11:20,210
if we're lucky.

1424
01:11:20,210 --> 01:11:22,270
You might also
insert an insertion.

1425
01:11:22,270 --> 01:11:24,640
That's basically the same
as deleting a deletion.

1426
01:11:24,640 --> 01:11:26,220
You get a whole
bunch of crossings.

1427
01:11:26,220 --> 01:11:30,050


1428
01:11:30,050 --> 01:11:32,680
Inserting an insertion
and deleting a deletion

1429
01:11:32,680 --> 01:11:34,330
are about the same.

1430
01:11:34,330 --> 01:11:36,880
So the other case is
inserting a deletion

1431
01:11:36,880 --> 01:11:40,670
or deleting an insertion.

1432
01:11:40,670 --> 01:11:44,200
So inserting a deletion.

1433
01:11:44,200 --> 01:11:48,170
Let's say that I
insert a deletion here.

1434
01:11:48,170 --> 01:11:51,220
So now suddenly this
thing ceases to exist.

1435
01:11:51,220 --> 01:11:52,540
All of this is gone.

1436
01:11:52,540 --> 01:11:54,280
We get not a crossing
error, but we

1437
01:11:54,280 --> 01:11:56,494
get what I'll call a
floating air, which

1438
01:11:56,494 --> 01:11:58,660
is that these guys are
currently returning something

1439
01:11:58,660 --> 01:12:02,290
that there's no segment there.

1440
01:12:02,290 --> 01:12:06,100
OK, so we can get crossing
errors and floating errors.

1441
01:12:06,100 --> 01:12:14,660


1442
01:12:14,660 --> 01:12:16,660
I want to give you enough
of this data structure

1443
01:12:16,660 --> 01:12:20,050
to show that actually you use
these data structures to solve

1444
01:12:20,050 --> 01:12:22,247
it.

1445
01:12:22,247 --> 01:12:24,455
So in that sense, it's
actually not that much easier.

1446
01:12:24,455 --> 01:12:25,996
I said it was easier,
but we're going

1447
01:12:25,996 --> 01:12:31,840
to need a retroactive successor
in order to solve this problem.

1448
01:12:31,840 --> 01:12:34,295
OK, some variants.

1449
01:12:34,295 --> 01:12:46,836


1450
01:12:46,836 --> 01:12:48,210
Man, who used this
colored chalk?

1451
01:12:48,210 --> 01:12:49,170
It's so hard to erase.

1452
01:12:49,170 --> 01:13:03,740


1453
01:13:03,740 --> 01:13:13,796
Let's say I want to maintain
the lowest leftmost crossing.

1454
01:13:13,796 --> 01:13:20,341


1455
01:13:20,341 --> 01:13:22,590
So in this picture, where I
have a bunch of crossings,

1456
01:13:22,590 --> 01:13:25,690
this is the one I want to
maintain, the bottom left one.

1457
01:13:25,690 --> 01:13:27,450
Now there's a bit
of a subtlety here,

1458
01:13:27,450 --> 01:13:29,984
which is do you do you
minimize y-coordinate

1459
01:13:29,984 --> 01:13:30,900
and then x-coordinate?

1460
01:13:30,900 --> 01:13:31,680
Or vice versa?

1461
01:13:31,680 --> 01:13:33,263
It turns out these
are the same thing.

1462
01:13:33,263 --> 01:13:36,760


1463
01:13:36,760 --> 01:13:40,590
I don't want to prove that here,
but because of this assumption

1464
01:13:40,590 --> 01:13:44,110
that we're always proceeding
monotonically left to right,

1465
01:13:44,110 --> 01:13:47,520
we have a nice invariant that if
you look at all the crossings,

1466
01:13:47,520 --> 01:13:51,144
they involve segments that
start to the left of all errors.

1467
01:13:51,144 --> 01:13:52,560
Because all the
changes we've made

1468
01:13:52,560 --> 01:13:56,010
are to the left of all
errors by this property.

1469
01:13:56,010 --> 01:13:57,660
And so it's really
just a whole bunch

1470
01:13:57,660 --> 01:14:00,840
of rays coming in from
negative infinity on the left,

1471
01:14:00,840 --> 01:14:03,630
and a whole bunch of rays
coming from minus infinity

1472
01:14:03,630 --> 01:14:05,010
on the bottom.

1473
01:14:05,010 --> 01:14:07,200
Sometimes the rays stop.

1474
01:14:07,200 --> 01:14:08,860
But if you look at
where they cross,

1475
01:14:08,860 --> 01:14:11,730
there's a uniquely defined
bottom left corner.

1476
01:14:11,730 --> 01:14:16,482
OK, so that's this picture.

1477
01:14:16,482 --> 01:14:21,090
Those rays might go different
amounts from either side,

1478
01:14:21,090 --> 01:14:24,910
but there is a single
lower left corner.

1479
01:14:24,910 --> 01:14:26,890
So we're going to maintain that.

1480
01:14:26,890 --> 01:14:38,220
And we're also going to maintain
the leftmost floating point,

1481
01:14:38,220 --> 01:14:44,330
floating error, on
each row separately.

1482
01:14:44,330 --> 01:14:46,949
So in each horizontal
line, like here,

1483
01:14:46,949 --> 01:14:48,990
we'll maintain that there's
a floating error here

1484
01:14:48,990 --> 01:14:49,980
for this row.

1485
01:14:49,980 --> 01:14:53,200
But we won't figure out
that one till later.

1486
01:14:53,200 --> 01:14:55,880
That just saves the
work we have to do.

1487
01:14:55,880 --> 01:15:06,360
OK, now let me show you an
operation let's do insert min.

1488
01:15:06,360 --> 01:15:07,236
So I want to--

1489
01:15:07,236 --> 01:15:08,610
I'm going to use
x for time here,

1490
01:15:08,610 --> 01:15:10,680
because it's a little
bit more intuitive.

1491
01:15:10,680 --> 01:15:12,660
X-coordinate is time.

1492
01:15:12,660 --> 01:15:14,430
Suppose I want to
insert a query.

1493
01:15:14,430 --> 01:15:17,580
This is actually an easy
case because there's

1494
01:15:17,580 --> 01:15:19,056
no chain reactions here.

1495
01:15:19,056 --> 01:15:21,680
It's going to be correct because
I'm doing the query right now.

1496
01:15:21,680 --> 01:15:24,300
This is basically a
fully retroactive query.

1497
01:15:24,300 --> 01:15:26,950
I'm adding a new
time, a new query,

1498
01:15:26,950 --> 01:15:29,220
and I want to know what is
the first ray that I hit.

1499
01:15:29,220 --> 01:15:32,830


1500
01:15:32,830 --> 01:15:33,760
How do I solve that?

1501
01:15:33,760 --> 01:15:37,800


1502
01:15:37,800 --> 01:15:43,380
So what's going on here is
I'm basically manipulating

1503
01:15:43,380 --> 01:15:46,020
these line segments.

1504
01:15:46,020 --> 01:15:50,070
I mean, the red lines don't
really affect this query.

1505
01:15:50,070 --> 01:15:51,337
They just might be incorrect.

1506
01:15:51,337 --> 01:15:52,920
But I don't care if
they're incorrect.

1507
01:15:52,920 --> 01:15:54,270
I just want to know
for this query, what

1508
01:15:54,270 --> 01:15:55,186
is the lowest segment?

1509
01:15:55,186 --> 01:15:56,560
So really, I have segments.

1510
01:15:56,560 --> 01:15:57,510
They're changing.

1511
01:15:57,510 --> 01:16:00,280
Inserting and deleting
endpoints of the segments.

1512
01:16:00,280 --> 01:16:03,330
And I want to know
from below, what is

1513
01:16:03,330 --> 01:16:05,190
the first segment that I hit?

1514
01:16:05,190 --> 01:16:08,810
This is called
upward ray-shooting.

1515
01:16:08,810 --> 01:16:10,620
Or vertical
ray-shooting, I guess,

1516
01:16:10,620 --> 01:16:12,960
would be the normal
phrasing, but I want

1517
01:16:12,960 --> 01:16:14,390
to be a little more specific.

1518
01:16:14,390 --> 01:16:17,610
Not downward upward.

1519
01:16:17,610 --> 01:16:18,975
Among dynamic segments.

1520
01:16:18,975 --> 01:16:22,589


1521
01:16:22,589 --> 01:16:23,880
This is a well-studied problem.

1522
01:16:23,880 --> 01:16:27,960


1523
01:16:27,960 --> 01:16:30,110
And conveniently, it can
be solved in log n time

1524
01:16:30,110 --> 01:16:30,750
preparation.

1525
01:16:30,750 --> 01:16:35,850
So you can modify segments and
do upward ray-shooting queries

1526
01:16:35,850 --> 01:16:37,620
in log n type preparation.

1527
01:16:37,620 --> 01:16:40,590
But you already knew that.

1528
01:16:40,590 --> 01:16:42,630
Good, you're nodding your head.

1529
01:16:42,630 --> 01:16:45,030
Because that is
retroactive successor,

1530
01:16:45,030 --> 01:16:46,520
if you think about it.

1531
01:16:46,520 --> 01:16:49,950
A retroactive insertion
operation in the past

1532
01:16:49,950 --> 01:16:52,620
is like its fully
retroactive successor.

1533
01:16:52,620 --> 01:16:55,260
That's this result.

1534
01:16:55,260 --> 01:16:57,720
Inserting an insertion,
that's like creating

1535
01:16:57,720 --> 01:16:59,670
a new left endpoint
point of a segment.

1536
01:16:59,670 --> 01:17:02,230
Inserting a deletion is like
creating a new right endpoint.

1537
01:17:02,230 --> 01:17:05,400
Deleting a deletion or
deleting an insertion,

1538
01:17:05,400 --> 01:17:07,870
you could use that
to move the endpoint.

1539
01:17:07,870 --> 01:17:12,600
So that's exactly dynamic
segments, horizontal segments.

1540
01:17:12,600 --> 01:17:15,660
And then shooting a ray is--

1541
01:17:15,660 --> 01:17:18,015
in general-- a general
ray-shooting query

1542
01:17:18,015 --> 01:17:18,780
is like this.

1543
01:17:18,780 --> 01:17:20,670
I can be not from
minus infinity,

1544
01:17:20,670 --> 01:17:24,840
be at an arbitrary point, and
ask, what do I hit upward next?

1545
01:17:24,840 --> 01:17:29,259
That is like at this time
doing a successor query.

1546
01:17:29,259 --> 01:17:31,050
OK, now this is a
special kind of successor

1547
01:17:31,050 --> 01:17:33,224
query, because it's always
from minus infinity.

1548
01:17:33,224 --> 01:17:34,890
So you might be able
to solve it easier.

1549
01:17:34,890 --> 01:17:39,610
But in particular, you can
solve it using this result.

1550
01:17:39,610 --> 01:17:43,710
So regular retroactivity
helps you do nonoblivious

1551
01:17:43,710 --> 01:17:45,828
retroactivity.

1552
01:17:45,828 --> 01:17:46,328
Cool.

1553
01:17:46,328 --> 01:17:53,090


1554
01:17:53,090 --> 01:17:54,860
We're out of time.

1555
01:17:54,860 --> 01:18:00,686
So I will just say, the
other cases are similar.

1556
01:18:00,686 --> 01:18:02,310
There's one other
thing you need to do,

1557
01:18:02,310 --> 01:18:04,490
which is in addition
to upward ray-shooting,

1558
01:18:04,490 --> 01:18:06,747
you have to do rightward
ray-shooting because

1559
01:18:06,747 --> 01:18:07,580
of things like this.

1560
01:18:07,580 --> 01:18:09,020
If I delete this
deletion, I want

1561
01:18:09,020 --> 01:18:10,394
to know what do I hit next.

1562
01:18:10,394 --> 01:18:11,810
So that's a rightward
ray-shooting

1563
01:18:11,810 --> 01:18:13,730
among dynamic segments,
which all happen

1564
01:18:13,730 --> 01:18:15,530
to start at minus infinity.

1565
01:18:15,530 --> 01:18:20,050
So it's again-- it's dynamic
ray-shooting, or successor

1566
01:18:20,050 --> 01:18:23,450
queries, but in x instead of y.

1567
01:18:23,450 --> 01:18:25,310
So with those tricks,
you can do all

1568
01:18:25,310 --> 01:18:27,410
of the cases of
inserting deleting,

1569
01:18:27,410 --> 01:18:31,850
deleting insertions,
inserting, all combinations

1570
01:18:31,850 --> 01:18:33,760
of those things.

1571
01:18:33,760 --> 01:18:38,711